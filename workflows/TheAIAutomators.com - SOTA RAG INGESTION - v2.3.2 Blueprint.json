{
  "active": false,
  "activeVersion": null,
  "activeVersionId": null,
  "connections": {
    "Generate Hash": {
      "main": [
        [
          {
            "node": "Search Record Manager",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search Record Manager": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Row in Record Manager": {
      "main": [
        [
          {
            "node": "Set up Record ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items": {
      "main": [
        [],
        [
          {
            "node": "Set Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Previous Vectors": {
      "main": [
        [
          {
            "node": "Aggregate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update our Record Manager": {
      "main": [
        [
          {
            "node": "Set up Record ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate": {
      "main": [
        [
          {
            "node": "Update our Record Manager",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Text": {
      "main": [
        [
          {
            "node": "Set Text (Merged)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set up Text for Embedding": {
      "main": [
        [
          {
            "node": "Smart Chunker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Markdown",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload File": {
      "main": [
        [
          {
            "node": "Get File URL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "New Files": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Updated Files": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "If2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Data": {
      "main": [
        [
          {
            "node": "File Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If2": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Archive File": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Trigger Firecrawl",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop over Chunks": {
      "main": [
        [
          {
            "node": "Aggregate2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Contextual embedding enabled?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "If Record is Complete",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create Row in Record Manager",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Delete Previous Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate2": {
      "main": [
        [
          {
            "node": "Update our Record Manager1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser2": {
      "ai_outputParser": [
        [
          {
            "node": "Enrich",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model3": {
      "ai_languageModel": [
        [
          {
            "node": "Enrich",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Metadata Fields": {
      "main": [
        [
          {
            "node": "If3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prep": {
      "main": [
        [
          {
            "node": "Enrich",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrich": {
      "main": [
        [
          {
            "node": "Set up Text for Embedding",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is LightRAG enabled?": {
      "main": [
        [
          {
            "node": "Remove Page Number Placeholders",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Fetch Metadata Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is LightRAG enabled?1": {
      "main": [
        [
          {
            "node": "Check data type1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Next",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Multimodal enabled?": {
      "main": [
        [
          {
            "node": "Base64 File",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Is OCR enabled?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get a document": {
      "main": [
        [
          {
            "node": "Set Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from Excel": {
      "main": [
        [
          {
            "node": "Aggregate3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from CSV": {
      "main": [
        [
          {
            "node": "Aggregate3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summarize": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Get row(s) in sheet": {
      "main": [
        [
          {
            "node": "Aggregate3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Array keys": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Set Text for Tabular Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get google sheet info": {
      "main": [
        [
          {
            "node": "Get row(s) in sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate3": {
      "main": [
        [
          {
            "node": "Array keys",
            "type": "main",
            "index": 0
          },
          {
            "node": "Summarize",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch1": {
      "main": [
        [
          {
            "node": "Extract from text file",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract from text file",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get a document",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Is Multimodal enabled?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Upload file to LlamaParse",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract from CSV",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract from Excel",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get google sheet info",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Move to Error Folder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Text (Merged)": {
      "main": [
        [
          {
            "node": "If4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Text for Tabular Data": {
      "main": [
        [
          {
            "node": "Set Text (Merged)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Data Rows": {
      "main": [
        [
          {
            "node": "data_rows",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Out": {
      "main": [
        [
          {
            "node": "Insert rows in a table",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check data type": {
      "main": [
        [
          {
            "node": "Delete Old Data Rows",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Is LightRAG enabled?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "data_rows": {
      "main": [
        [
          {
            "node": "Split Out",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert rows in a table": {
      "main": [
        [
          {
            "node": "Aggregate4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Workflow": {
      "main": [
        [
          {
            "node": "Set Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Knowledge Graph Updates": {
      "main": [
        [
          {
            "node": "Wait3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Contextual embedding enabled?": {
      "main": [
        [
          {
            "node": "Wait2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Setup Chunk for Embedding1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunk with contextual embedding": {
      "main": [
        [
          {
            "node": "Setup Chunk for Embedding1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check data type1": {
      "main": [
        [],
        [
          {
            "node": "Remove Page Number Placeholders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Processing Status": {
      "main": [
        [
          {
            "node": "Counter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Job Ready?": {
      "main": [
        [
          {
            "node": "Get parsed document",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Track",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Track",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Track",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload file to LlamaParse": {
      "main": [
        [
          {
            "node": "Wait1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get parsed document": {
      "main": [
        [
          {
            "node": "Set Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "Get Processing Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait1": {
      "main": [
        [
          {
            "node": "Set counter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Counter": {
      "main": [
        [
          {
            "node": "Is Job Ready?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set counter": {
      "main": [
        [
          {
            "node": "Is Job Ready?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send tabular data to vector store?": {
      "main": [
        [
          {
            "node": "Fetch Metadata Fields",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Continue",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate4": {
      "main": [
        [
          {
            "node": "Send tabular data to vector store?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create OpenAI Embeddings": {
      "main": [
        [
          {
            "node": "Setup Chunk for Batch Insertion",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Setup Chunk for Embedding1": {
      "main": [
        [
          {
            "node": "Create OpenAI Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Setup Chunk for Batch Insertion": {
      "main": [
        [
          {
            "node": "Insert into Vector Store",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert into Vector Store": {
      "main": [
        [
          {
            "node": "Loop over Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is OCR enabled?": {
      "main": [
        [
          {
            "node": "Upload File",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If4": {
      "main": [
        [
          {
            "node": "Generate Hash",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Continue",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sanitize Text": {
      "main": [
        [
          {
            "node": "Set Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get File URL": {
      "main": [
        [
          {
            "node": "Get OCR",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get OCR": {
      "main": [
        [
          {
            "node": "Aggregate Markdown with Page Numbers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Text": {
      "main": [
        [
          {
            "node": "Sanitize Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Base64 File": {
      "main": [
        [
          {
            "node": "Execute Workflow",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If3": {
      "main": [
        [
          {
            "node": "Prep",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Enrich",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set up Record ID": {
      "main": [
        [
          {
            "node": "Check data type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Continue": {
      "main": [
        [
          {
            "node": "Next1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webpage Markdown": {
      "main": [
        [
          {
            "node": "Set Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "File Check": {
      "main": [
        [
          {
            "node": "Webpage Markdown",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Main File Download",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from text file": {
      "main": [
        [
          {
            "node": "Set Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Main File Download": {
      "main": [
        [
          {
            "node": "Switch1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Markdown": {
      "main": [
        [
          {
            "node": "Set Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Move to Error Folder": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Track": {
      "main": [
        [
          {
            "node": "Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error": {
      "main": [
        [
          {
            "node": "Move to Error Folder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait2": {
      "main": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Next": {
      "main": [
        [
          {
            "node": "Continue",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Markdown with Page Numbers": {
      "main": [
        [
          {
            "node": "Set Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Smart Chunker": {
      "main": [
        [
          {
            "node": "Document Hierarchy Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Document Hierarchy Extractor": {
      "main": [
        [
          {
            "node": "Merger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merger": {
      "main": [
        [
          {
            "node": "Split Out1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Out1": {
      "main": [
        [
          {
            "node": "Loop over Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update our Record Manager1": {
      "main": [
        [
          {
            "node": "Next1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Next1": {
      "main": [
        [
          {
            "node": "If a file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If a file": {
      "main": [
        [
          {
            "node": "Archive File",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remove Page Number Placeholders": {
      "main": [
        [
          {
            "node": "Execute Knowledge Graph Updates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain": {
      "main": [
        [
          {
            "node": "Chunk with contextual embedding",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Record is Complete": {
      "main": [
        [
          {
            "node": "Is LightRAG enabled?1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Delete Previous Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update our Record Manager2": {
      "main": [
        [
          {
            "node": "Stop and Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Message": {
      "main": [
        [
          {
            "node": "Update our Record Manager2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-11-02T22:28:00.931Z",
  "id": "T5shLbYURAidLgsc",
  "isArchived": false,
  "meta": null,
  "name": "TheAIAutomators.com - SOTA RAG INGESTION - v2.3.2 Blueprint",
  "nodes": [
    {
      "parameters": {
        "type": "SHA256",
        "value": "={{ $json.text }}",
        "dataPropertyName": "hash"
      },
      "type": "n8n-nodes-base.crypto",
      "typeVersion": 1,
      "position": [
        1456,
        4912
      ],
      "id": "893b5d13-dd80-4d55-95ee-b172d5af4c4b",
      "name": "Generate Hash"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "record_manager_v2",
        "limit": 1,
        "filters": {
          "conditions": [
            {
              "keyName": "doc_id",
              "condition": "eq",
              "keyValue": "={{ $('Set Data').first().json.doc_id }}"
            },
            {
              "keyName": "hash",
              "condition": "eq",
              "keyValue": "={{ $json.hash }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1696,
        4912
      ],
      "id": "9dfb8a64-28af-4127-a2b9-63d71e128dc1",
      "name": "Search Record Manager",
      "alwaysOutputData": true,
      "retryOnFail": true
    },
    {
      "parameters": {
        "tableId": "record_manager_v2",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "doc_id",
              "fieldValue": "={{ $('Set Data').first().json.doc_id }}"
            },
            {
              "fieldId": "hash",
              "fieldValue": "={{ $('Generate Hash').item.json.hash }}"
            },
            {
              "fieldId": "graph_id",
              "fieldValue": "={{ $json.foundDocumentId }}"
            },
            {
              "fieldId": "data_type",
              "fieldValue": "={{ $('Set Text (Merged)').first().json.data_type }}"
            },
            {
              "fieldId": "schema",
              "fieldValue": "={{ $('Set Text (Merged)').first().json.array_keys || null }}"
            },
            {
              "fieldId": "document_title",
              "fieldValue": "={{ $('Set Data').first().json.doc_name }}"
            },
            {
              "fieldId": "status",
              "fieldValue": "processing"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2832,
        4784
      ],
      "id": "e37d4729-48ef-449f-ab40-547351fa80b3",
      "name": "Create Row in Record Manager",
      "retryOnFail": true
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        1008,
        1376
      ],
      "id": "5d360a92-a47b-44cc-8177-fd413905892f",
      "name": "Loop Over Items"
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "documents_v2",
        "filterType": "string",
        "filterString": "=metadata->>doc_id=like.*{{ $('Loop Over Items').item.json.id }}*"
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2560,
        5072
      ],
      "id": "720e6d2d-7490-4aec-8c1d-005f6ac21d7c",
      "name": "Delete Previous Vectors",
      "alwaysOutputData": true,
      "retryOnFail": true
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "record_manager_v2",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Search Record Manager').item.json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "hash",
              "fieldValue": "={{ $('Generate Hash').item.json.hash }}"
            },
            {
              "fieldId": "status",
              "fieldValue": "processing"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        3040,
        5072
      ],
      "id": "f0b500ec-e2c4-4102-9c82-60e53bdfdd60",
      "name": "Update our Record Manager",
      "retryOnFail": true
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        2816,
        5072
      ],
      "id": "f05c4cbe-fbba-4bfe-857f-de015df1ce51",
      "name": "Aggregate"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "a27d8259-8ed2-4638-8716-b60119b8f90c",
              "name": "text",
              "value": "={{ $json.content || $json.text || $json.markdown}}",
              "type": "string"
            },
            {
              "id": "57ffce94-6b26-426f-9891-cd436002bf6d",
              "name": "data_type",
              "value": "unstructured",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        7968,
        1728
      ],
      "id": "0c11edc6-4d98-4c94-b6c5-83c442e29194",
      "name": "Set Text"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "90016f21-d4be-4e57-a81a-5fe290f388b9",
              "name": "content",
              "value": "={{ $('Set Text (Merged)').item.json.text }}",
              "type": "string"
            },
            {
              "id": "6e2ac31c-3626-4a48-8816-51a77601261b",
              "name": "custom_metadata",
              "value": "={{ $json.output }}",
              "type": "object"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        5424,
        5024
      ],
      "id": "d71181ed-ed02-4fb5-b2a0-8c4a0159d417",
      "name": "Set up Text for Embedding"
    },
    {
      "parameters": {
        "operation": "text",
        "destinationKey": "content",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        5568,
        1776
      ],
      "id": "bc414bdb-9432-4c9f-b78e-fc7e29296466",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.mistral.ai/v1/files",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "mistralCloudApi",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            },
            {
              "name": "purpose",
              "value": "ocr"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        5552,
        1392
      ],
      "id": "79b98ba7-6c9d-4e33-ad0b-92d2bbb8cc05",
      "name": "Upload File",
      "retryOnFail": true
    },
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "triggerOn": "specificFolder",
        "folderToWatch": {
          "__rl": true,
          "value": "11lXb2f7enCxgeP6HROWqDWzfIz3vX_Kv",
          "mode": "id"
        },
        "event": "fileCreated",
        "options": {}
      },
      "type": "n8n-nodes-base.googleDriveTrigger",
      "typeVersion": 1,
      "position": [
        528,
        1376
      ],
      "id": "3fa3b6db-1764-4fdf-b4e0-b08ce5ae4e77",
      "name": "New Files",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "BcBZ0GrlNhnoa3MJ",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "triggerOn": "specificFolder",
        "folderToWatch": {
          "__rl": true,
          "value": "12345",
          "mode": "id"
        },
        "event": "fileUpdated",
        "options": {}
      },
      "type": "n8n-nodes-base.googleDriveTrigger",
      "typeVersion": 1,
      "position": [
        528,
        1616
      ],
      "id": "0734ec6b-f59e-404b-8329-7a9d89bf6454",
      "name": "Updated Files"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.firecrawl.dev/v1/crawl",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBearerAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"url\": \"https://www.theaiautomators.com/blog/\",\n  \"limit\": 5,\n  \"webhook\": {\n    \"url\": \"<ADD WEBHOOK>\",\n    \"events\": [\n      \"page\"\n    ]\n  },\n  \"scrapeOptions\": {\n    \"formats\": [\n      \"markdown\"\n    ]\n  }\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        752,
        656
      ],
      "id": "a1240930-4eef-44fc-ab14-4bf0a8378031",
      "name": "Trigger Firecrawl",
      "retryOnFail": false
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "788b2977-a0b3-4393-9dd2-047ca9a10cb7",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        528,
        1136
      ],
      "id": "db2b1669-4ae7-42d4-bdfe-f9a506d79ac9",
      "name": "Webhook",
      "webhookId": "788b2977-a0b3-4393-9dd2-047ca9a10cb7"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d0f85312-1655-44ed-ab5d-4db71c7b3f03",
              "name": "lightrag_enabled",
              "value": false,
              "type": "boolean"
            },
            {
              "id": "31b25dec-c322-4862-85cd-1746156618fd",
              "name": "multimodal_rag_enabled",
              "value": false,
              "type": "boolean"
            },
            {
              "id": "9d686a90-a000-415f-99cd-056798d561f7",
              "name": "ocr_enabled",
              "value": false,
              "type": "boolean"
            },
            {
              "id": "6e9b9a47-9dc9-4912-8833-c934ec3e5d89",
              "name": "contextual_embedding_enabled",
              "value": false,
              "type": "boolean"
            },
            {
              "id": "be837843-d308-4b1a-88f1-a6b20cc66029",
              "name": "send_tabular_data_to_vector_store",
              "value": false,
              "type": "boolean"
            },
            {
              "id": "fdba4635-3d3a-46fe-84f2-a0797cc5d81d",
              "name": "llamaparse_max_polling_attempts",
              "value": 200,
              "type": "number"
            },
            {
              "id": "39bd7383-0385-459d-85d4-126bc25347ca",
              "name": "doc_id",
              "value": "={{ $json.id || $json.body.data[0].metadata.url }}",
              "type": "string"
            },
            {
              "id": "eabda515-4cc4-49c9-9299-88aa34071946",
              "name": "doc_name",
              "value": "={{ $json.name || $json.body.data[0].metadata.title }}",
              "type": "string"
            },
            {
              "id": "464bcef6-ec45-44fd-aa9e-49bd3ecf6bf6",
              "name": "doc_type",
              "value": "={{ $('Webhook').isExecuted ? \"webpage\" : \"file\" }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1632,
        1552
      ],
      "id": "da3ff792-137c-46a0-9ea4-8c98339ee9c1",
      "name": "Set Data"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "4db8114c-c34f-4bc6-8c9e-78d7388e9b56",
              "leftValue": "={{ $json.body.data[0].markdown.length }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gte"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        736,
        1136
      ],
      "id": "0d24be9c-9058-4001-b0aa-7de855f4b2ea",
      "name": "If2"
    },
    {
      "parameters": {
        "operation": "move",
        "fileId": {
          "__rl": true,
          "value": "={{ $('Set Data').first().json.doc_id }}",
          "mode": "id"
        },
        "driveId": {
          "__rl": true,
          "value": "My Drive",
          "mode": "list",
          "cachedResultName": "My Drive",
          "cachedResultUrl": "https://drive.google.com/drive/my-drive"
        },
        "folderId": {
          "__rl": true,
          "value": "12345",
          "mode": "id"
        }
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        528,
        2384
      ],
      "id": "85704b8a-a2aa-4c26-aa4c-726c1440e098",
      "name": "Archive File",
      "retryOnFail": true
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "months",
              "monthsInterval": 10
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        528,
        656
      ],
      "id": "b3a5f516-55b7-47f5-8a4d-973fb6044749",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "batchSize": 50,
        "options": {
          "reset": "={{ $node['Loop over Chunks'].context.done }}"
        }
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        6336,
        5024
      ],
      "id": "f25262c7-b227-4a15-899f-9980fca33324",
      "name": "Loop over Chunks"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "dcd400bc-0b91-4c30-81bd-da402e4a2730",
                    "leftValue": "={{ $json.hash }}",
                    "rightValue": "={{ $('Generate Hash').item.json.hash }}",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json }}",
                    "rightValue": "",
                    "operator": {
                      "type": "object",
                      "operation": "empty",
                      "singleValue": true
                    },
                    "id": "ad01f150-f021-454c-aa13-eea5b26c2cba"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "ca0c7ef8-09f9-4424-947b-8469b1ed8cac",
                    "leftValue": "={{ $json.hash }}",
                    "rightValue": "={{ $('Generate Hash').item.json.hash }}",
                    "operator": {
                      "type": "string",
                      "operation": "notEquals"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        1872,
        4880
      ],
      "id": "a340495d-72bf-48b2-9a30-90b539d0ae20",
      "name": "Switch"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        7424,
        5424
      ],
      "id": "bc28bf98-7919-4ce1-a942-e9871f7862a0",
      "name": "Aggregate2"
    },
    {
      "parameters": {
        "content": "# Knowledge Graph Updates",
        "height": 472,
        "width": 1508,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        3328,
        3904
      ],
      "id": "8a05a921-8c99-49cc-a341-e734bdf7e5cc",
      "name": "Sticky Note14"
    },
    {
      "parameters": {
        "content": "## File Format Router & Extraction",
        "height": 2776,
        "width": 5424,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        3408,
        560
      ],
      "id": "981b7d20-2889-467f-85f1-24e5a9e92964",
      "name": "Sticky Note9"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Generic Object with String or Number Values\",\n  \"type\": \"object\",\n  \"additionalProperties\": {\n    \"type\": [\"string\", \"number\"]\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        5040,
        4816
      ],
      "id": "b99cf0f5-046a-46c5-b619-b1e2e54e6b70",
      "name": "Structured Output Parser2"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-5-mini",
          "mode": "list",
          "cachedResultName": "gpt-5-mini"
        },
        "options": {
          "responseFormat": "json_object"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        4880,
        4816
      ],
      "id": "f75e2bfb-cd6a-42a3-9ae0-082f1d42bf7a",
      "name": "OpenAI Chat Model3"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "metadata_fields"
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        4176,
        4880
      ],
      "id": "9908c406-6d74-455b-a320-50b766dd05c3",
      "name": "Fetch Metadata Fields",
      "retryOnFail": true,
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Get input items\nconst items = $input.all();\n\n// Initialize output string and list of fields\nlet output = '';\nlet fieldList = '';\n\n// Loop through each input item\nfor (const item of items) {\n  const data = item.json;\n\n  const key = data.metadata_name;\n  const values = data.allowed_values;\n\n  output += `## ${key}\\n`;\n  output += `The filter key ${key} can have the following possible values\\n\\n`;\n  output += `${values.trim()}\\n\\n`;\n\n  fieldList += `\"${key}\":\"<ADD>\",\\n`;\n}\n\n// Remove trailing comma and newline from fieldList\nfieldList = fieldList.trim().replace(/,\\s*$/, '');\n\n// Take the first item and modify it with aggregated data\nconst firstItem = items[0];\nfirstItem.json.filterPromptInstructions = output.trim();\nfirstItem.json.list_of_fields = fieldList;\n\n// Return only the first item (now containing aggregated data)\nreturn [firstItem];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4560,
        4640
      ],
      "id": "64cbdb89-6a80-4889-b4ee-e04ef66c0716",
      "name": "Prep"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=# File Name\n{{ $('Set Data').item.json.doc_name }}\n##################\n# File Contents\n{{ \n$('Set Text (Merged)').first().json.text.length > 10000 \n    ? $('Set Text (Merged)').first().json.text.substring(0, 10000) + '...' \n    : $('Set Text (Merged)').first().json.text \n}}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=Based on the provided file name and file contents, extract out ...\n\n# headline-style description\n\nA very short, headline-style description (7-10 words). This will be used to finish the sentence \"This chunk is from\" so start it with \"an\" or \"a\"... example output\n\nan SEC filing on ACME corp's performance in Q2 2023\n\n# document summary\n\nAlso extract out a 1 sentence description of what the document is about and classify the document according to the below fields.\n\nOnly output JSON in the following format\n\n{\n\"document_headline_description\":\"<ADD>\",\n\"document_summary\":\"<ADD>\",\n{{ $json.list_of_fields ? $json.list_of_fields : \"\" }}\n}\n\nIf you are unsure of any of these, just output N/A in the field.\n\n{{ $json.list_of_fields ? $json.filterPromptInstructions : \"\" }}"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        4896,
        4608
      ],
      "id": "cbc4eb24-7d9c-4e58-a809-7fb818848b20",
      "name": "Enrich",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Set Data').first().json.lightrag_enabled }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "ff677730-3b6a-41af-b46e-69c0610d9ea2"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "If LightRAG enabled"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "ba8b00e1-09f7-4729-a3f2-1a0526e1b9f8",
                    "leftValue": "1",
                    "rightValue": "1",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Always execute"
            }
          ]
        },
        "options": {
          "allMatchingOutputs": true
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        3856,
        4752
      ],
      "id": "4ce2b1b5-4200-473d-af38-271098056eba",
      "name": "Is LightRAG enabled?"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Set Data').first().json.lightrag_enabled }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "ff677730-3b6a-41af-b46e-69c0610d9ea2"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "If LightRAG enabled"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "918f53c3-a48f-4cf4-a005-2c3c6e43da39",
                    "leftValue": "1",
                    "rightValue": "1",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Always execute"
            }
          ]
        },
        "options": {
          "allMatchingOutputs": true
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        3440,
        4192
      ],
      "id": "2fa2cd19-f89a-49de-af14-b21c0c28a791",
      "name": "Is LightRAG enabled?1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4a63774b-98fb-4f42-af92-5bf4ff6017ca",
              "leftValue": "={{ $('Set Data').item.json.multimodal_rag_enabled }}",
              "rightValue": 10,
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        4608,
        1200
      ],
      "id": "fac98e68-7fed-4c89-be17-e5b0d496f94d",
      "name": "Is Multimodal enabled?"
    },
    {
      "parameters": {
        "operation": "get",
        "documentURL": "={{ $json.id }}"
      },
      "type": "n8n-nodes-base.googleDocs",
      "typeVersion": 2,
      "position": [
        5264,
        912
      ],
      "id": "6ca43233-a0bf-4fa0-87a4-ea7d862e280a",
      "name": "Get a document",
      "retryOnFail": true
    },
    {
      "parameters": {
        "operation": "xlsx",
        "options": {}
      },
      "id": "c2294e82-d3b5-4c58-97b0-35f63bf3ef6a",
      "name": "Extract from Excel",
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        5344,
        2784
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        5344,
        2576
      ],
      "id": "6bba1a74-fa76-42e2-9bc4-a3290c5604df",
      "name": "Extract from CSV"
    },
    {
      "parameters": {
        "fieldsToSummarize": {
          "values": [
            {
              "aggregation": "concatenate",
              "field": "data"
            }
          ]
        },
        "options": {}
      },
      "id": "ede1edcb-3477-4770-b27b-9e52437305c4",
      "name": "Summarize",
      "type": "n8n-nodes-base.summarize",
      "typeVersion": 1,
      "position": [
        6800,
        2720
      ]
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "={{ $('Loop Over Items').item.json.id }}",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": "={{ $json.sheets[0].properties.sheetId }}",
          "mode": "id"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        5344,
        2992
      ],
      "id": "c3273a47-b32c-4169-bf98-56cbbd588470",
      "name": "Get row(s) in sheet",
      "retryOnFail": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "98ed8f1b-f706-4829-8010-cf33b8eaf1d2",
              "name": "array_keys",
              "value": "={{ $json.data.first().keys() }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        6800,
        2528
      ],
      "id": "6526729e-8d62-4bd1-b150-657ed8c25911",
      "name": "Array keys"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        7216,
        2592
      ],
      "id": "80a8c22f-ae5b-4d42-9b93-eea9cc69718a",
      "name": "Merge"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "a27d8259-8ed2-4638-8716-b60119b8f90c",
              "name": "text",
              "value": "={{ $json.concatenated_data }}",
              "type": "string"
            },
            {
              "id": "ccab898b-7018-41cf-9418-ccfca0509259",
              "name": "array_keys",
              "value": "={{ $json.array_keys }}",
              "type": "string"
            },
            {
              "id": "6b696d19-a500-46e4-92a6-4b0148ddb153",
              "name": "data_type",
              "value": "tabular",
              "type": "string"
            },
            {
              "id": "c91004d6-3bcc-4542-ad90-8eea6bd78707",
              "name": "data_rows",
              "value": "={{ $('Aggregate3').item.json.data }}",
              "type": "array"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        7696,
        2592
      ],
      "id": "7ed25bb9-c505-4141-85f1-114b2f93ec91",
      "name": "Set Text for Tabular Data"
    },
    {
      "parameters": {
        "url": "=https://sheets.googleapis.com/v4/spreadsheets/{{ $('Loop Over Items').item.json.id }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleSheetsOAuth2Api",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        4400,
        2736
      ],
      "id": "e4999794-d857-4278-b1b8-c30c614310f0",
      "name": "Get google sheet info",
      "retryOnFail": true
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "include": "allFieldsExcept",
        "fieldsToExclude": "row_number",
        "options": {}
      },
      "id": "1f9d2061-90dc-4d11-a7d9-9f13c111f259",
      "name": "Aggregate3",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        6528,
        2640
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "01e6c26b-2cd8-4280-bcd6-b714a6f6f8fb",
                    "leftValue": "={{ $json.mimeType }}",
                    "rightValue": "text/plain",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Plain Text"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "f0c334e4-fd56-4768-8c9b-31b4e1e39b04",
                    "leftValue": "={{ $json.mimeType }}",
                    "rightValue": "text/markdown",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Markdown"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.mimeType }}",
                    "rightValue": "application/vnd.google-apps.document",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "9e010d7f-0552-4a06-9566-e3031ffae240"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Google Docs"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "ddac5320-959a-4634-9000-c9cdc397d2e4",
                    "leftValue": "={{ $json.mimeType }}",
                    "rightValue": "application/pdf",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "PDF"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "b94191c9-1f29-4558-a4ac-3a74e9f5d88f",
                    "leftValue": "={{ $json.mimeType }}",
                    "rightValue": "text/html",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "HTML"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "296bdf72-6d94-487b-9276-66bbee45c801",
                    "leftValue": "={{ [\n  // Documents / Presentations / Spreadsheets\n  \"application/x-t602\",                          // 602\n  \"application/x-abiword\",                       // abw, zabw\n  \"image/cgm\",                                   // cgm\n  \"application/x-appleworks\",                    // cwk\n  \"application/msword\",                          // doc\n  \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\", // docx\n  \"application/vnd.ms-word.document.macroEnabled.12\", // docm\n  \"application/msword\",                          // dot\n  \"application/vnd.ms-word.template.macroEnabled.12\", // dotm\n  \"application/x-hwp\",                           // hwp\n  \"application/vnd.apple.keynote\",               // key\n  \"application/vnd.lotus-wordpro\",               // lwp\n  \"application/x-mw\",                            // mw\n  \"application/x-mcw\",                           // mcw\n  \"application/vnd.apple.pages\",                 // pages\n  \"application/vnd.powerbuilder6\",               // pbd\n  \"application/vnd.ms-powerpoint\",               // ppt\n  \"application/vnd.ms-powerpoint.presentation.macroEnabled.12\", // pptm\n  \"application/vnd.openxmlformats-officedocument.presentationml.presentation\", // pptx\n  \"application/vnd.ms-powerpoint\",               // pot\n  \"application/vnd.ms-powerpoint.template.macroEnabled.12\", // potm\n  \"application/vnd.openxmlformats-officedocument.presentationml.template\", // potx\n  \"application/rtf\",                             // rtf\n  \"application/vnd.stardivision.draw\",           // sda\n  \"application/vnd.stardivision.impress\",        // sdd\n  \"application/sdp\",                             // sdp\n  \"application/vnd.stardivision.writer\",         // sdw, sgl\n  \"application/vnd.sun.xml.impress.template\",    // sti\n  \"application/vnd.sun.xml.impress\",             // sxi\n  \"application/vnd.sun.xml.writer\",              // sxw\n  \"application/vnd.sun.xml.writer.template\",     // stw\n  \"application/vnd.sun.xml.writer.global\",       // sxg\n  \"text/plain\",                                  // txt\n  \"application/x-uof\",                           // uof\n  \"application/x-uop\",                           // uop\n  \"application/x-uot\",                           // uot\n  \"application/vnd.stardivision.writer\",         // vor\n  \"application/vnd.wordperfect\",                 // wpd\n  \"application/vnd.ms-works\",                    // wps\n  \"application/xml\",                             // xml\n  \"application/epub+zip\",                        // epub\n\n  // Images\n  \"image/jpeg\",                                  // jpg, jpeg\n  \"image/png\",                                   // png\n  \"image/gif\",                                   // gif\n  \"image/bmp\",                                   // bmp\n  \"image/svg+xml\",                               // svg\n  \"image/tiff\",                                  // tiff\n  \"image/webp\",                                  // webp\n\n  // Audio / Video\n  \"audio/mpeg\",                                  // mp3, mpga\n  \"video/mp4\",                                   // mp4\n  \"video/mpeg\",                                  // mpeg\n  \"audio/mp4\",                                   // m4a\n  \"audio/wav\",                                   // wav\n  \"video/webm\",                                  // webm\n  \"audio/webm\"                                   // webm (audio)\n].includes($json.mimeType) }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Other doc types"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "656e77d3-0b79-4f95-a950-93f24506f8ce",
                    "leftValue": "={{ $json.mimeType }}",
                    "rightValue": "text/csv",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CSV"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "84f9cf5d-6348-43fc-b5cd-2833b4c9dd5f",
                    "leftValue": "={{ $json.mimeType }}",
                    "rightValue": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Excel"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "0ceeb2c2-9931-479c-b105-36f9ef0381b1",
                    "leftValue": "={{ $json.mimeType }}",
                    "rightValue": "application/vnd.google-apps.spreadsheet",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Google Sheets"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        3392,
        1376
      ],
      "id": "862ae561-cacc-48bd-9e71-fcbd9c4484b4",
      "name": "Switch1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "65a2b6a1-2817-4d30-a0a3-ba1baeffe286",
              "name": "text",
              "value": "={{ $json.text }}",
              "type": "string"
            },
            {
              "id": "8ce1313f-d7ec-4336-88e7-1b861379733d",
              "name": "data_type",
              "value": "={{ $json.data_type }}",
              "type": "string"
            },
            {
              "id": "d1c52fad-f1af-46de-aa21-387bcb350309",
              "name": "array_keys",
              "value": "={{ $json.array_keys || null }}",
              "type": "string"
            },
            {
              "id": "68e7090d-0fba-4d63-a3d7-d3a10b17905c",
              "name": "data_rows",
              "value": "={{ $json.data_rows || null }}",
              "type": "array"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        8192,
        2352
      ],
      "id": "fd74484b-838c-4a56-9923-f7b1fecba357",
      "name": "Set Text (Merged)"
    },
    {
      "parameters": {
        "content": "# Tabular Data",
        "height": 464,
        "width": 1776,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        5136,
        3904
      ],
      "id": "62b0c12e-76c3-4eb7-a745-0ac15e3aadc2",
      "name": "Sticky Note23"
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "tabular_document_rows",
        "filters": {
          "conditions": [
            {
              "keyName": "record_manager_id",
              "condition": "eq",
              "keyValue": "={{ $('Set up Record ID').item.json.record_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        5312,
        4016
      ],
      "id": "9bfd8222-ae81-4203-afd0-b9631ea31278",
      "name": "Delete Old Data Rows",
      "alwaysOutputData": true,
      "executeOnce": true,
      "retryOnFail": true
    },
    {
      "parameters": {
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "tabular_document_rows",
          "mode": "list",
          "cachedResultName": "tabular_document_rows"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "row_data": "={{ $json.toJsonString().replaceAll(/'/g, \"''\") }}",
            "record_manager_id": "={{ $('Set up Record ID').item.json.record_id }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "created_at",
              "displayName": "created_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "record_manager_id",
              "displayName": "record_manager_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "row_data",
              "displayName": "row_data",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "object",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        6032,
        4016
      ],
      "id": "a1008dd0-fd2d-487c-b95f-ef901166dddc",
      "name": "Insert rows in a table",
      "retryOnFail": true
    },
    {
      "parameters": {
        "fieldToSplitOut": "=data_rows",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        5792,
        4016
      ],
      "id": "bb4546bc-b487-4b94-aefa-17acd35da21c",
      "name": "Split Out"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "c9e3737c-f583-4bc3-8d89-31deb8a4a167",
                    "leftValue": "={{ $('Set Text (Merged)').item.json.data_type }}",
                    "rightValue": "tabular",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Tabular data"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Set Text (Merged)').item.json.data_type }}",
                    "rightValue": "unstructured",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "b013e0cd-4c9f-4123-84cf-91f87b92dc76"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Unstructured data"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        3648,
        4656
      ],
      "id": "5c2ab583-c361-4c41-ab53-c7b28259447d",
      "name": "Check data type"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "8feea590-03e5-4da9-acf1-071537ee5b92",
              "name": "data_rows",
              "value": "={{ $('Set Text (Merged)').item.json.data_rows }}",
              "type": "array"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        5552,
        4016
      ],
      "id": "99802f2e-c544-43c8-aaa7-84696d6ab0d8",
      "name": "data_rows"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "xYznj1HOqGxHjDN9",
          "mode": "list",
          "cachedResultUrl": "/workflow/xYznj1HOqGxHjDN9",
          "cachedResultName": "Multimodal RAG - TheAIAutomators - SOTA RAG Sub-workflow - v1.2 Blueprint"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "binary_file": "={{ $json.data_base64 }}"
          },
          "matchingColumns": [
            "binary_file"
          ],
          "schema": [
            {
              "id": "binary_file",
              "displayName": "binary_file",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        5792,
        1200
      ],
      "id": "2d40ed4e-f5c8-4587-9127-553e1c98e08f",
      "name": "Execute Workflow"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "A6uZWZp8UkcxmaZp",
          "mode": "list",
          "cachedResultUrl": "/workflow/A6uZWZp8UkcxmaZp",
          "cachedResultName": "Knowledge Graph - TheAIAutomators - SOTA RAG Sub-workflow - v1.1 Blueprint"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "record_manager_item_json": "={{ $('Search Record Manager').item.json }}",
            "record_manager_item_json_hash": "={{ $('Search Record Manager').item.json.hash }}",
            "new_hash": "={{ $('Generate Hash').item.json.hash }}",
            "text": "={{ JSON.stringify($json.text) }}",
            "doc_id": "={{ $('Set Data').first().json.doc_id }}",
            "supabase_row_id": "={{ $('Create Row in Record Manager').isExecuted ? $('Create Row in Record Manager').item.json.id : $('Search Record Manager').item.json.id }}",
            "graph_id": "={{ $('Search Record Manager').item.json.graph_id}}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "record_manager_item_json",
              "displayName": "record_manager_item_json",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "object"
            },
            {
              "id": "record_manager_item_json_hash",
              "displayName": "record_manager_item_json_hash",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "new_hash",
              "displayName": "new_hash",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "doc_id",
              "displayName": "doc_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "text",
              "displayName": "text",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "supabase_row_id",
              "displayName": "supabase_row_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number"
            },
            {
              "id": "graph_id",
              "displayName": "graph_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        4352,
        4048
      ],
      "id": "99c4d843-ef34-49d5-8c5e-9782de39635a",
      "name": "Execute Knowledge Graph Updates",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "15ce0e44-3fcb-4b60-83b6-8e6e721ff266",
              "leftValue": "={{ $('Set Data').first().json.contextual_embedding_enabled }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        6656,
        4944
      ],
      "id": "e0440ad1-f133-4256-b82d-0ddbc98773a1",
      "name": "Contextual embedding enabled?"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "63096a5f-5247-474b-95b4-cbeadca1f982",
              "name": "content",
              "value": "={{ $json.text }} - {{ $('Loop over Chunks').all()[$itemIndex].json.content }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        7568,
        4800
      ],
      "id": "6283e101-d30f-4649-94c9-e89e8b732f07",
      "name": "Chunk with contextual embedding"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "c9e3737c-f583-4bc3-8d89-31deb8a4a167",
                    "leftValue": "={{ $('Set Text (Merged)').first().json.data_type }}",
                    "rightValue": "tabular",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Tabular data"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Set Text (Merged)').first().json.data_type }}",
                    "rightValue": "unstructured",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "b013e0cd-4c9f-4123-84cf-91f87b92dc76"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Unstructured data"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        3776,
        4032
      ],
      "id": "7243f6d4-13c9-4be9-926d-b39471e3b8f7",
      "name": "Check data type1"
    },
    {
      "parameters": {
        "url": "=https://api.cloud.llamaindex.ai/api/parsing/job/{{ $('Upload file to LlamaParse').item.json.id }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "accept",
              "value": "application/json"
            }
          ]
        },
        "options": {}
      },
      "id": "fc3b5c2d-8c7c-4d70-a8d5-78b7d32bcf07",
      "name": "Get Processing Status",
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        6384,
        2304
      ],
      "typeVersion": 4.2,
      "retryOnFail": true
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "300fce8c-b19a-4d0c-86e8-f62853c70ce2",
                    "operator": {
                      "name": "filter.operator.equals",
                      "type": "string",
                      "operation": "equals"
                    },
                    "leftValue": "={{ $json.status }}",
                    "rightValue": "SUCCESS"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "SUCCESS"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "e6058aa0-a3e2-4ce3-9bed-6ff41a5be052",
                    "operator": {
                      "name": "filter.operator.equals",
                      "type": "string",
                      "operation": "equals"
                    },
                    "leftValue": "={{ $json.status }}",
                    "rightValue": "ERROR"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "ERROR"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "ceb6338f-4261-40ac-be11-91f61c7302ba",
                    "operator": {
                      "type": "number",
                      "operation": "gt"
                    },
                    "leftValue": "={{ $json.retry_counter }}",
                    "rightValue": "={{ $('Set Data').item.json.llamaparse_max_polling_attempts }}"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "EXCEEDED_RETRIES"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "ceb6338f-4261-40ac-be11-91f61c7302ba",
                    "operator": {
                      "name": "filter.operator.equals",
                      "type": "string",
                      "operation": "equals"
                    },
                    "leftValue": "={{ $json.status }}",
                    "rightValue": "CANCELED"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CANCELED"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "0fa97d86-432a-409a-917e-5f1a002b1ab9",
                    "operator": {
                      "name": "filter.operator.equals",
                      "type": "string",
                      "operation": "equals"
                    },
                    "leftValue": "={{ $json.status }}",
                    "rightValue": "PENDING"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "PENDING"
            }
          ]
        },
        "options": {
          "allMatchingOutputs": false
        }
      },
      "id": "37063597-d934-4fae-aba5-70b7ddbe2c2c",
      "name": "Is Job Ready?",
      "type": "n8n-nodes-base.switch",
      "position": [
        5904,
        2064
      ],
      "typeVersion": 3
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.cloud.llamaindex.ai/api/parsing/upload",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "accept",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "=data"
            },
            {
              "name": "model",
              "value": "openai-gpt-4-1-mini"
            },
            {
              "name": "high_res_ocr",
              "value": "true"
            },
            {
              "name": "adaptive_long_table",
              "value": "true"
            },
            {
              "name": "outlined_table_extraction",
              "value": "true"
            },
            {
              "name": "output_tables_as_HTML",
              "value": "false"
            }
          ]
        },
        "options": {}
      },
      "id": "a2b38f8e-e6d7-4203-bfa3-5de802190a67",
      "name": "Upload file to LlamaParse",
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        4736,
        1984
      ],
      "typeVersion": 4.2,
      "retryOnFail": true
    },
    {
      "parameters": {
        "url": "=https://api.cloud.llamaindex.ai/api/parsing/job/{{ $json.id }}/result/markdown",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {
          "redirect": {
            "redirect": {}
          }
        }
      },
      "id": "fc2374ef-8b1e-40e1-9570-5c15935c141c",
      "name": "Get parsed document",
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        6128,
        1936
      ],
      "typeVersion": 4.2,
      "retryOnFail": true
    },
    {
      "parameters": {
        "amount": 3
      },
      "id": "af71c456-17f0-454a-8ac6-cbd9cdf070c4",
      "name": "Wait",
      "type": "n8n-nodes-base.wait",
      "position": [
        6128,
        2256
      ],
      "webhookId": "36c73a09-89bd-4a27-aba0-084aa7d2a987",
      "typeVersion": 1.1
    },
    {
      "parameters": {
        "amount": 7
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        5184,
        2032
      ],
      "id": "4fd6379e-1468-478d-ac5f-10f2951ece18",
      "name": "Wait1",
      "webhookId": "a8f5059d-c449-4319-841b-f3da2bb3eb13"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "b53d0b18-0e5e-4b24-915d-933cd7a241b5",
              "name": "retry_counter",
              "value": "={{ $('Is Job Ready?').item.json.retry_counter + 1}}",
              "type": "number"
            },
            {
              "id": "48d8fa5f-8935-4c27-8b72-05af922886c9",
              "name": "status",
              "value": "={{ $json.status }}",
              "type": "string"
            },
            {
              "id": "e8c53db0-a41b-44cc-a0ef-9effcb4b94f8",
              "name": "id",
              "value": "={{ $json.id }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        5504,
        2256
      ],
      "id": "f2c4e773-bd82-4d6c-8c53-96ef45be76ef",
      "name": "Counter"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "3533c696-8cb4-4be8-967a-555f88dbca3c",
              "name": "retry_counter",
              "value": 0,
              "type": "number"
            },
            {
              "id": "0c517b55-97fb-4d4b-835b-930cf72c4738",
              "name": "status",
              "value": "={{ $('Upload file to LlamaParse').item.json.status }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        5424,
        2048
      ],
      "id": "9201808d-20aa-4965-9a04-47befdefbf7a",
      "name": "Set counter"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "c9e3737c-f583-4bc3-8d89-31deb8a4a167",
                    "leftValue": "={{ $('Set Data').item.json.send_tabular_data_to_vector_store }}",
                    "rightValue": "tabular",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Yes"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        6672,
        4144
      ],
      "id": "a499e0d4-ca59-468f-be5e-cb42b31689b1",
      "name": "Send tabular data to vector store?"
    },
    {
      "parameters": {
        "fieldsToAggregate": {
          "fieldToAggregate": [
            {
              "fieldToAggregate": "id"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        6336,
        4016
      ],
      "id": "d2d45460-310b-4f27-b7da-81869d618426",
      "name": "Aggregate4"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"text-embedding-3-small\",\n  \"input\": {{ JSON.stringify($json.contents) }}\n}\n",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        8144,
        4960
      ],
      "id": "870c880f-7cfb-49b4-acbc-0d4b65452cc4",
      "name": "Create OpenAI Embeddings",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 2500,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Aggregate all chunk strings into one array and attach to the first item only\nconst items = $input.all();\n\n// Build contents from items that look like { json: { chunk: \"...\" } }\nconst contents = items\n  .map(it => it.json?.content)\n  .filter(s => typeof s === 'string' && s.trim() !== '');\n\n// Use the first item as the carrier\nconst first = items[0] ?? { json: {} };\nfirst.json.contents = contents;\n\nreturn [first];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7872,
        4992
      ],
      "id": "68074aaa-7dd9-475c-9191-d5db997f3bfd",
      "name": "Setup Chunk for Embedding1"
    },
    {
      "parameters": {
        "jsCode": "// Input: OpenAI response with multiple embeddings\nconst embeddings = $input.first().json.data; // Array of embedding objects\nconst originalContents = $('Setup Chunk for Embedding1').first().json.contents;\nconst loopItems = $('Loop over Chunks').all();\n\n// Get the record_manager_id (adjust node name as needed)\nconst recordManagerId = $('Create Row in Record Manager').isExecuted ? $('Create Row in Record Manager').first().json.id : $('Search Record Manager').first().json.id\n\n// Prepare data for batch insert using parameterized queries\nconst insertData = embeddings.map(embeddingObj => {\n  const index = embeddingObj.index;\n  const embedding = embeddingObj.embedding;\n  const content = originalContents[index];\n  \n  return {\n    content: content,\n    metadata: JSON.stringify(loopItems[index].json.metadata),\n    embedding: embedding, // Keep as array, let the DB driver handle conversion\n    record_manager_id: recordManagerId // Add the foreign key\n  };\n});\n\n// Generate parameterized query (now with 4 parameters per row)\nconst placeholders = insertData.map((_, index) => {\n  const base = index * 4; // Changed from 3 to 4\n  return `($${base + 1}, $${base + 2}, $${base + 3}::vector, $${base + 4})`;\n}).join(',\\n');\n\nconst insertQuery = `\n  INSERT INTO documents_v2 (content, metadata, embedding, record_manager_id) \n  VALUES ${placeholders}\n`;\n\n// Flatten the parameters array (now includes record_manager_id)\nconst parameters = insertData.flatMap(row => [\n  row.content,\n  row.metadata,\n  `[${row.embedding.join(',')}]`, // Format vector as string for PostgreSQL\n  row.record_manager_id\n]);\n\nreturn [{\n  insertQuery: insertQuery,\n  parameters: parameters,\n  recordCount: insertData.length,\n  batchInfo: `Processed indices: ${embeddings.map(e => e.index).join(', ')}`\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8400,
        4960
      ],
      "id": "d3ce5139-81fe-4dbb-a00e-88328d00cbcf",
      "name": "Setup Chunk for Batch Insertion"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "{{ $json.insertQuery }}",
        "options": {
          "queryReplacement": "={{ $json.parameters }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        8688,
        5024
      ],
      "id": "6435e8c4-cc8a-4e77-a55e-ddf38a7bb0e8",
      "name": "Insert into Vector Store",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 2500
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "48e8abfe-dbee-4273-a7ba-bde4efb0df28",
              "leftValue": "={{ $('Set Data').item.json.ocr_enabled }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        4880,
        1392
      ],
      "id": "842ee4e6-38b9-42df-ad1d-6d309dfd4a6f",
      "name": "Is OCR enabled?"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "40cb0058-f77e-4cb8-9cd5-7774c1c72544",
              "leftValue": "={{ $json.text }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        9600,
        3472
      ],
      "id": "83b2cc14-b070-461e-956f-3425df7dac02",
      "name": "If4"
    },
    {
      "parameters": {
        "jsCode": "// Function to clean Unicode escape sequences\nfunction cleanUnicodeText(text) {\n  if (typeof text !== 'string') return text;\n  \n  return text\n    // Remove control characters like \\u0002, \\u0000, etc.\n    .replace(/[\\u0000-\\u001F\\u007F-\\u009F]/g, '')\n    // Clean up extra whitespace\n    .replace(/\\s+/g, ' ')\n    .trim();\n}\n\n// Loop over input items and clean the content field\nfor (const item of $input.all()) {\n  // Clean the content field if it exists\n  if (item.json.content) {\n    item.json.content = cleanUnicodeText(item.json.content);\n  }\n  \n  // Optional: Clean all string fields in the item\n  Object.keys(item.json).forEach(key => {\n    if (typeof item.json[key] === 'string') {\n      item.json[key] = cleanUnicodeText(item.json[key]);\n    }\n  });\n}\n\nreturn $input.all();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5760,
        1584
      ],
      "id": "22aa1d25-e62c-4199-91f9-5410cd8cc823",
      "name": "Sanitize Text"
    },
    {
      "parameters": {
        "url": "=https://api.mistral.ai/v1/files/{{ $json.id }}/url",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "mistralCloudApi",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "expiry",
              "value": "24"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        5792,
        1392
      ],
      "id": "94a0737f-9ac5-4de5-8eaf-c094d4830c9d",
      "name": "Get File URL",
      "retryOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.mistral.ai/v1/ocr",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "mistralCloudApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"mistral-ocr-latest\",\n  \"document\": {\n    \"type\": \"document_url\",\n    \"document_url\": \"{{ $json.url }}\"\n  },\n  \"include_image_base64\": false\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        6016,
        1392
      ],
      "id": "ee4dc1ca-3eff-4565-ba89-358a74b58012",
      "name": "Get OCR",
      "retryOnFail": true
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        5552,
        1584
      ],
      "id": "a841c68b-5137-44f1-af8d-0e629a9ec8f2",
      "name": "Extract Text"
    },
    {
      "parameters": {
        "operation": "binaryToPropery",
        "destinationKey": "data_base64",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        5504,
        1200
      ],
      "id": "c857ed71-695a-4c06-ae0f-ce78e77487d3",
      "name": "Base64 File"
    },
    {
      "parameters": {
        "content": "## Loop Start\nOnly Supports Processing 1 File at a time. For parallel imports check out our \"RAG at Scale\" System",
        "height": 288,
        "width": 256,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        960,
        1248
      ],
      "id": "7898c7ed-69fa-4e13-964f-04e25d51cba5",
      "name": "Sticky Note31"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "a4697977-31b6-4740-ae7c-0e3a35ecfdf0",
              "leftValue": "={{ $json }}",
              "rightValue": "",
              "operator": {
                "type": "object",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        4384,
        4880
      ],
      "id": "1b7031cc-c423-4c9a-843b-e9697ce02ae4",
      "name": "If3"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "2cb5d7fc-ea46-460e-bb1e-21756214930a",
              "name": "record_id",
              "value": "={{ $json.id }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3424,
        4848
      ],
      "id": "f21afb6b-a382-4221-9e92-f7444a8c79da",
      "name": "Set up Record ID"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        9968,
        4432
      ],
      "id": "ca5b6465-99fd-42be-a6ae-8cedd017bfeb",
      "name": "Continue"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "3a9c47ef-1799-4cf6-9411-51c4789e2adb",
              "name": "markdown",
              "value": "={{ $json.body.data[0].markdown }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        5232,
        592
      ],
      "id": "aad0ddc8-2718-4fad-bb52-91ecee894007",
      "name": "Webpage Markdown"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4f60ed7e-4284-4360-bca2-4513859e7dde",
              "leftValue": "={{ $('Webhook').isExecuted }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1680,
        1472
      ],
      "id": "4acae5bb-c81e-4273-9d80-a9f890254dab",
      "name": "File Check"
    },
    {
      "parameters": {
        "operation": "text",
        "destinationKey": "content",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        5392,
        720
      ],
      "id": "cb84829b-1d3d-471a-a77b-2e91f09b5208",
      "name": "Extract from text file"
    },
    {
      "parameters": {
        "content": "## TODO: Add Webhook\nFrom the Webhook node below",
        "height": 280,
        "width": 264
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        688,
        560
      ],
      "id": "f8c89f69-47ee-45a8-b9ae-05e7451b99cf",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "={{ $('Loop Over Items').item.json.id }}",
          "mode": "id"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        2432,
        1600
      ],
      "id": "89380e6d-0a82-467b-bf24-a2154e0ce4ba",
      "name": "Main File Download",
      "retryOnFail": true
    },
    {
      "parameters": {
        "html": "={{ $json.content }}",
        "destinationKey": "content",
        "options": {}
      },
      "type": "n8n-nodes-base.markdown",
      "typeVersion": 1,
      "position": [
        5856,
        1776
      ],
      "id": "07a59d05-4d1d-416f-8171-2a19761a685a",
      "name": "Markdown"
    },
    {
      "parameters": {
        "operation": "move",
        "fileId": {
          "__rl": true,
          "value": "={{ $('Set Data').first().json.doc_id }}",
          "mode": "id"
        },
        "driveId": {
          "__rl": true,
          "value": "My Drive",
          "mode": "list",
          "cachedResultName": "My Drive",
          "cachedResultUrl": "https://drive.google.com/drive/my-drive"
        },
        "folderId": {
          "__rl": true,
          "value": "12345",
          "mode": "id"
        }
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        1376,
        2048
      ],
      "id": "39973932-1baa-421e-a898-5750965cabda",
      "name": "Move to Error Folder",
      "retryOnFail": true
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        8192,
        2112
      ],
      "id": "497566c2-e152-480b-ac0c-4cd7108b74cb",
      "name": "Error Track"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        9600,
        3264
      ],
      "id": "d86297bb-096c-4e94-94aa-68c2fed1a6f1",
      "name": "Error"
    },
    {
      "parameters": {
        "amount": 0.1
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        6928,
        4816
      ],
      "id": "f13193c5-14ee-45bd-9811-2dd1ec03ae08",
      "name": "Wait2",
      "webhookId": "83d6b920-6b4b-481a-b405-5e833520194d"
    },
    {
      "parameters": {
        "content": "## Rate Limiting\nIf you run in to Rate Limiting issues with contextual vector embeddings, you can increase this wait node",
        "height": 288,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        6864,
        4656
      ],
      "id": "d4025cdc-5d21-4bee-b02b-5713a5080b50",
      "name": "Sticky Note34"
    },
    {
      "parameters": {
        "content": "[![The AI Automators](https://www.theaiautomators.com/wp-content/uploads/2025/03/gray-logo.png)](https://www.theaiautomators.com/)",
        "height": 220,
        "width": 580,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        16,
        16
      ],
      "id": "ed2235ca-cf0c-4579-b7a3-76eab674a17b",
      "name": "Sticky Note10"
    },
    {
      "parameters": {
        "content": "",
        "height": 456,
        "width": 616,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "id": "ffa85385-eace-4c86-8bbf-6642f4142a50",
      "name": "Sticky Note18"
    },
    {
      "parameters": {
        "content": "# SOTA RAG Ingestion v2.3\nSetup instructions here:\nhttps://community.theaiautomators.com/c/automation-templates/state-of-the-art-n8n-rag-agent",
        "height": 180,
        "width": 580,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        16,
        256
      ],
      "id": "9a688654-9c6f-46f5-bea9-89c097770c5e",
      "name": "Sticky Note21"
    },
    {
      "parameters": {
        "content": "@[youtube](75lwkzFxyLs)",
        "height": 384,
        "width": 656,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        672,
        0
      ],
      "id": "b2e0ef4d-f827-4d91-8ba1-cda53398bf76",
      "name": "Sticky Note8"
    },
    {
      "parameters": {
        "content": "# RAG File Creation & Update\nActivate the workflow and then upload files to the Google Drive folder\n\nNote: Google drive Triggers do not fire when you move files in between folders",
        "height": 228,
        "width": 424,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        0,
        1392
      ],
      "id": "6a7c15d0-000e-46c6-af79-96732c53602a",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "content": "# Webscraping Creation & Update",
        "height": 180,
        "width": 424,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        0,
        1104
      ],
      "id": "09bb0ded-26a1-4b45-95eb-19ce4f16c37f",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "content": "## TODO\n### Enable/Disable Services Here",
        "height": 280,
        "width": 280
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1296,
        1376
      ],
      "id": "e5a2f11b-38c3-40ce-8b48-e9359d989198",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "content": "## TODO\nMultimodal RAG sub-workflow must be configured if Multimodal is enabled in the \"Set Data\" node.",
        "height": 292,
        "width": 272
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        5712,
        1072
      ],
      "id": "88fabd4c-f31f-4819-80d1-c832dceb859c",
      "name": "Sticky Note25"
    },
    {
      "parameters": {
        "content": "## TODO\nGraphRAG sub-workflow must be configured if LightRAG is enabled in the \"Set Data\" node.",
        "height": 308,
        "width": 272
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        4272,
        3920
      ],
      "id": "46257b17-ebd0-4dcb-b92e-c170fb36f983",
      "name": "Sticky Note26"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        3840,
        4400
      ],
      "id": "339153bc-a1bf-4419-9853-7009b9fcbaa8",
      "name": "Next"
    },
    {
      "parameters": {
        "content": "# Record Manager Router\n\n### 0. No Change to Doc\nMove to next file\n\n### 1. New Document\nAdd to Record Manager and Vector Store \n\n### 2. Changed Document \nDelete old vectors and add new ones",
        "height": 820,
        "width": 2668,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1424,
        4544
      ],
      "id": "84c5d885-f061-4624-af4c-739170692de2",
      "name": "Sticky Note11"
    },
    {
      "parameters": {
        "content": "# Document & Metadata Enrichment",
        "height": 820,
        "width": 1184,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        4128,
        4544
      ],
      "id": "aea54d03-ed82-41cb-8ca0-bb0bfe48c639",
      "name": "Sticky Note7"
    },
    {
      "parameters": {
        "content": "# Smart Markdown Chunking & Hierarchy Extractor",
        "height": 820,
        "width": 1188,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        5344,
        4544
      ],
      "id": "efcfc6ec-c567-4115-90eb-1eecb5cafad4",
      "name": "Sticky Note17"
    },
    {
      "parameters": {
        "content": "## Rate Limiting - Batch Size\nIf you run in to Rate Limiting issues with contextual vector embeddings, you will need to reduce this",
        "height": 336,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        6272,
        4848
      ],
      "id": "4d2b4fa3-beb4-408a-999c-21704efd7ab3",
      "name": "Sticky Note33"
    },
    {
      "parameters": {
        "content": "# Contextual Vector Embeddings",
        "height": 820,
        "width": 1204,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        6560,
        4544
      ],
      "id": "499dd494-5984-464d-ad3e-2e7169716302",
      "name": "Sticky Note15"
    },
    {
      "parameters": {
        "content": "# Insert to Supabase Vector Store",
        "height": 820,
        "width": 1220,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        7792,
        4544
      ],
      "id": "03b00aa2-f855-4bf0-8862-4649da679fb4",
      "name": "Sticky Note16"
    },
    {
      "parameters": {
        "content": "## TODO\nOptionally Change Embedding Model ",
        "height": 320,
        "width": 256
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        8064,
        4832
      ],
      "id": "eb3c8b37-69c8-4af2-a946-6b4e0fe5b107",
      "name": "Sticky Note28"
    },
    {
      "parameters": {
        "content": "# Trigger Webscraping",
        "height": 180,
        "width": 424,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        0,
        624
      ],
      "id": "3cdffb05-f3fb-4856-98dd-3f9d8fde952e",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "jsCode": "// Page-Aware Markdown Aggregation for n8n Code Node\n// Use a unique delimiter that won't appear in documents\nconst PAGE_MARKER_START = '<<<PAGE_START:';\nconst PAGE_MARKER_END = '>>>';\n\n// Get the first item to process\nconst firstItem = $input.first();\n\n// Check if pages exist in the first item\nif (firstItem.json.pages && Array.isArray(firstItem.json.pages)) {\n  // Aggregate pages with page markers\n  const aggregatedMarkdown = firstItem.json.pages.map((page, index) => {\n    const pageNumber = page.index !== undefined ? page.index : index;\n    const pageMarker = `${PAGE_MARKER_START}${pageNumber}${PAGE_MARKER_END}`;\n    \n    // Insert page marker at the beginning of each page's content\n    return `${pageMarker}\\n\\n${page.markdown}`;\n  }).join('\\n\\n');\n  \n  // Return only the first item with aggregated markdown\n  return [{\n    json: {\n      content: aggregatedMarkdown\n    }\n  }];\n} else {\n  // Handle case where pages don't exist or aren't an array\n  return [{\n    json: {\n      content: firstItem.json.content || ''\n    }\n  }];\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6416,
        1424
      ],
      "id": "a867ceb8-a979-4b81-aa48-5accaeddcdde",
      "name": "Aggregate Markdown with Page Numbers"
    },
    {
      "parameters": {
        "jsCode": "// Smart Markdown Chunker for n8n Code Node\n// Configuration - adjust these values as needed\nconst MIN_CHUNK_SIZE = 400;\nconst TARGET_CHUNK_SIZE = 600;\nconst MAX_CHUNK_SIZE = 800; // Note: Chunks can go over this size to both avoid tiny chunks as well as account for the contextual snippet and if there is more then one heading per chunk\nconst MAX_HEADING_LENGTH = 200   // For heading truncation in split chunks\n\n// Page marker configuration\nconst PAGE_MARKER_START = '<<<PAGE_START:';\nconst PAGE_MARKER_END = '>>>';\n\n// Mappings\nconst MARKDOWN_FIELD = 'content'  // Field name, not the actual content\nconst DOCUMENT_ID_FIELD = $('Set Data').first().json.doc_id\nconst DOCUMENT_NAME = $('Set Data').first().json.doc_name\nconst DOCUMENT_SUMMARY = $input.first().json.custom_metadata.document_summary\nconst DOCUMENT_HEADLINE = \"This chunk is from \" + $input.first().json.custom_metadata.document_headline_description + \", specifically \"\nconst DEV_MODE = false; // Enable to include debug fields for testing\n\n// Classes\nclass HierarchyNode {\n  constructor(title, level) {\n    this.title = title;\n    this.level = level;\n  }\n}\n\nclass MarkdownChunk {\n  constructor(data) {\n    this.title = data.title;\n    this.level = data.level;\n    this.cascading_path = data.cascading_path;\n    this.content = data.content;\n    this.hierarchy_stack = data.hierarchy_stack;\n    this.original_level = data.original_level;\n    this.is_merged = data.is_merged || false;\n    this.is_split = data.is_split || false;\n    this.split_part_index = data.split_part_index || null;\n    this.total_split_parts = data.total_split_parts || null;\n    this.original_chunk_title = data.original_chunk_title || null;\n    this.original_cascading_path = data.original_cascading_path || null;\n    this.merged_type = data.merged_type || null;\n    this.original_chunks = data.original_chunks || null;\n    this.merged_chunk_count = data.merged_chunk_count || 1;\n    this.enhanced_content_raw = data.enhanced_content_raw || null;\n  }\n}\n\nclass SmartMarkdownChunker {\n  constructor(minChunkSize, maxChunkSize, targetChunkSize, devMode = false) {\n    this.MIN_CHUNK_SIZE = minChunkSize;\n    this.MAX_CHUNK_SIZE = maxChunkSize;\n    this.TARGET_CHUNK_SIZE = targetChunkSize;\n    this.DEV_MODE = devMode;\n    this._document_summary = 'No summary available';\n    this._total_chunks = 0;\n    \n    // Markdown-aware separators (from LangChain approach)\n    this.MARKDOWN_SEPARATORS = [\n      \"\\n## \", \"\\n### \", \"\\n#### \", \"\\n##### \", \"\\n###### \",\n      \"```\\n\\n\", \"\\n\\n***\\n\\n\", \"\\n\\n---\\n\\n\", \"\\n\\n___\\n\\n\",\n      \"\\n\\n\", \"\\n\", \". \", \" \", \"\"\n    ];\n  }\n\n  // STEP 1: Parse markdown by major headings (H1, H2, H3, H4, H5, H6)\n  parseMarkdownSections(markdown, headingLevels = [1, 2, 3, 4, 5, 6]) {\n    const lines = markdown.split('\\n');\n    const sections = [];\n    let currentSection = null;\n    let currentContent = [];\n    const hierarchyStack = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      const headingMatch = line.match(/^(#+)\\s*(.*)$/);\n      \n      if (headingMatch) {\n        const level = headingMatch[1].length;\n        \n        // Only split on specified heading levels\n        if (headingLevels.includes(level)) {\n          // Save previous section if it exists\n          if (currentSection && currentContent.length > 0) {\n            currentSection.content = currentContent.join('\\n');\n            sections.push(currentSection);\n          }\n\n          const originalTitle = headingMatch[2].trim();\n          let displayTitle = originalTitle;\n\n          // Truncate extremely long headings for display\n          if (displayTitle.length > MAX_HEADING_LENGTH) {\n            displayTitle = displayTitle.substring(0, MAX_HEADING_LENGTH - 3) + '...';\n          }\n\n          // Update hierarchy stack\n          while (hierarchyStack.length >= level) {\n            hierarchyStack.pop();\n          }\n          hierarchyStack.push(new HierarchyNode(displayTitle, level));\n\n          currentSection = {\n            title: displayTitle,\n            level,\n            hierarchy_stack: JSON.parse(JSON.stringify(hierarchyStack)),\n            content: '',\n            original_title: originalTitle\n          };\n\n          currentContent = [line];\n        } else {\n          // Include sub-headings in content\n          currentContent.push(line);\n        }\n      } else {\n        currentContent.push(line);\n      }\n    }\n\n    // Don't forget the last section\n    if (currentSection && currentContent.length > 0) {\n      currentSection.content = currentContent.join('\\n');\n      sections.push(currentSection);\n    }\n\n    // If no major headings found, treat entire document as one section\n    if (sections.length === 0) {\n      sections.push({\n        title: 'Document',\n        level: 1,\n        hierarchy_stack: [new HierarchyNode('Document', 1)],\n        content: markdown,\n        original_title: 'Document'\n      });\n    }\n\n    return sections;\n  }\n\n  // STEP 2: Recursive markdown-aware splitting within sections\n  recursiveMarkdownSplit(text, separators = null) {\n    if (!separators) separators = this.MARKDOWN_SEPARATORS;\n    if (text.length <= this.MAX_CHUNK_SIZE) return [text];\n\n    for (const separator of separators) {\n      if (separator === \"\") {\n        // Character-by-character splitting as last resort\n        const chunks = [];\n        for (let i = 0; i < text.length; i += this.MAX_CHUNK_SIZE) {\n          chunks.push(text.slice(i, i + this.MAX_CHUNK_SIZE));\n        }\n        return chunks;\n      }\n\n      if (text.includes(separator)) {\n        const parts = text.split(separator);\n        const chunks = [];\n        let currentChunk = '';\n\n        for (let i = 0; i < parts.length; i++) {\n          const part = i === 0 ? parts[i] : separator + parts[i];\n          \n          if (currentChunk.length + part.length <= this.MAX_CHUNK_SIZE) {\n            currentChunk += part;\n          } else {\n            if (currentChunk) chunks.push(currentChunk);\n            \n            // If this part is still too large, recursively split it\n            if (part.length > this.MAX_CHUNK_SIZE) {\n              chunks.push(...this.recursiveMarkdownSplit(part, separators.slice(1)));\n            } else {\n              currentChunk = part;\n            }\n          }\n        }\n        \n        if (currentChunk) chunks.push(currentChunk);\n        return chunks.filter(chunk => chunk.trim().length > 0);\n      }\n    }\n\n    return [text];\n  }\n\n  splitSectionIntoChunks(section) {\n    const chunks = this.recursiveMarkdownSplit(section.content);\n    \n    return chunks.map((chunkContent, index) => {\n      let finalContent = chunkContent.trim();\n      \n      // For split chunks, add the original section heading with part number\n      if (chunks.length > 1) {\n        const headingPrefix = '#'.repeat(section.level);\n        \n        if (index === 0) {\n          // For Part 1, keep original text lossless - just add (Part 1) to existing heading\n          const originalHeading = `${headingPrefix} ${section.original_title} (Part ${index + 1})`;\n          const lines = finalContent.split('\\n');\n          const firstLineHeadingMatch = lines[0].match(/^#+\\s/);\n          if (firstLineHeadingMatch) {\n            lines[0] = originalHeading;\n            finalContent = lines.join('\\n');\n          } else {\n            finalContent = `${originalHeading}\\n\\n${finalContent}`;\n          }\n        } else {\n          // For Part 2+, add the heading at the start (trimmed for length)\n          let titleForHeading = section.original_title;\n          const partSuffix = ` (Part ${index + 1})`;\n          const maxTitleLength = MAX_HEADING_LENGTH - headingPrefix.length - partSuffix.length - 1; // -1 for space\n          \n          if (titleForHeading.length > maxTitleLength) {\n            titleForHeading = titleForHeading.substring(0, maxTitleLength - 3) + '...';\n          }\n          \n          const originalHeading = `${headingPrefix} ${titleForHeading}${partSuffix}`;\n          finalContent = `${originalHeading}\\n\\n${finalContent}`;\n        }\n      }\n      \n      return {\n        content: finalContent,\n        section_title: section.title,\n        section_level: section.level,\n        hierarchy_stack: section.hierarchy_stack,\n        original_section_title: section.original_title,\n        chunk_index_in_section: index,\n        total_chunks_in_section: chunks.length,\n        is_split: chunks.length > 1,\n        split_part_number: chunks.length > 1 ? index + 1 : null,\n        size: finalContent.length\n      };\n    });\n  }\n\n  // STEP 3: Merge small chunks intelligently\n  mergeSmallChunks(chunks) {\n    const result = [];\n    let i = 0;\n\n    while (i < chunks.length) {\n      const currentChunk = chunks[i];\n      \n      if (currentChunk.size >= this.MIN_CHUNK_SIZE) {\n        result.push(currentChunk);\n        i++;\n        continue;\n      }\n\n      // Try to merge with next chunk(s)\n      let mergedContent = currentChunk.content;\n      let mergedSize = currentChunk.size;\n      let chunksToMerge = [currentChunk];\n      let j = i + 1;\n\n      while (j < chunks.length && mergedSize < this.MIN_CHUNK_SIZE) {\n        const nextChunk = chunks[j];\n        const testSize = mergedSize + nextChunk.size + 2; // +2 for \\n\\n separator\n        \n        // Allow going over MAX_CHUNK_SIZE to avoid tiny chunks\n        if (testSize <= this.MAX_CHUNK_SIZE * 1.2 || mergedSize < this.MIN_CHUNK_SIZE) {\n          mergedContent += '\\n\\n' + nextChunk.content;\n          mergedSize = testSize;\n          chunksToMerge.push(nextChunk);\n          j++;\n        } else {\n          break;\n        }\n      }\n\n      // Find if any merged chunk is a split part\n      const splitChunk = chunksToMerge.find(chunk => chunk.is_split);\n      \n      // Create merged chunk\n      const mergedChunk = {\n        content: mergedContent,\n        section_title: currentChunk.section_title,\n        section_level: currentChunk.section_level,\n        hierarchy_stack: currentChunk.hierarchy_stack,\n        original_section_title: currentChunk.original_section_title,\n        chunk_index_in_section: currentChunk.chunk_index_in_section,\n        total_chunks_in_section: currentChunk.total_chunks_in_section,\n        is_split: splitChunk ? splitChunk.is_split : currentChunk.is_split,\n        split_part_number: splitChunk ? splitChunk.split_part_number : currentChunk.split_part_number,\n        is_merged: chunksToMerge.length > 1,\n        merged_chunk_count: chunksToMerge.length,\n        size: mergedSize,\n        original_chunks: chunksToMerge.length > 1 ? chunksToMerge : null\n      };\n\n      result.push(mergedChunk);\n      i = j;\n    }\n\n    return result;\n  }\n\n  // STEP 4: Add document headline to final chunks\n  addDocumentHeadline(chunks, headline) {\n    if (!headline) return chunks;\n\n    return chunks.map(chunk => ({\n      ...chunk,\n      content: `${headline}${chunk.content}`,\n      size: chunk.content.length + headline.length\n    }));\n  }\n\n  // Extract page information from chunk content\n  extractPageInfo(content) {\n    const pageMarkerRegex = new RegExp(`${PAGE_MARKER_START.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}(\\\\d+)${PAGE_MARKER_END.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}`, 'g');\n    const pages = [];\n    let match;\n    \n    while ((match = pageMarkerRegex.exec(content)) !== null) {\n      pages.push(parseInt(match[1]));\n    }\n    \n    // Remove duplicates and sort\n    return [...new Set(pages)].sort((a, b) => a - b);\n  }\n\n  // Clean page markers from content\n  cleanPageMarkers(content) {\n    const pageMarkerRegex = new RegExp(`${PAGE_MARKER_START.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\d+${PAGE_MARKER_END.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\s*\\\\n?\\\\n?`, 'g');\n    return content.replace(pageMarkerRegex, '').trim();\n  }\n\n  // Create metadata for chunks\n  createChunkMetadata(chunks) {\n    let currentPage = 0; // Start with page 0 (which is page 1 in human terms)\n    \n    return chunks.map((chunk, index) => {\n      // Extract page information before cleaning\n      const pagesInChunk = this.extractPageInfo(chunk.content);\n      \n      // Determine all pages this chunk spans\n      let chunkPages = [];\n      \n      if (pagesInChunk.length > 0) {\n        // This chunk contains page markers - include all pages found + current page\n        const allPages = [currentPage, ...pagesInChunk];\n        chunkPages = [...new Set(allPages)].sort((a, b) => a - b);\n        // Update current page to the highest page found\n        currentPage = Math.max(...pagesInChunk);\n      } else {\n        // No page markers in this chunk - inherit current page\n        chunkPages = [currentPage];\n      }\n      \n      // Clean the content of page markers\n      const cleanContent = this.cleanPageMarkers(chunk.content);\n      chunk.content = cleanContent;\n      \n      const metadata = {\n        chunk_index: index,\n        content_length: cleanContent.length,\n        pages: chunkPages.map(p => p + 1) // Convert to human-readable page numbers (1, 2, 3...)\n      };\n\n      // Add section information for context\n      metadata.cascading_path = chunk.hierarchy_stack ? \n        chunk.hierarchy_stack.map(node => node.title).join(' > ') : \n        chunk.section_title;\n\n      // Add split part information if applicable\n      if (chunk.is_split && chunk.split_part_number) {\n        metadata.split_part_number = chunk.split_part_number;\n        metadata.total_chunks_in_section = chunk.total_chunks_in_section;\n      }\n\n      if (this.DEV_MODE) {\n        // Size analysis\n        metadata.meets_size_requirements = chunk.size >= this.MIN_CHUNK_SIZE && chunk.size <= this.MAX_CHUNK_SIZE;\n        metadata.size_category = chunk.size < this.MIN_CHUNK_SIZE ? 'small' :\n          chunk.size > this.MAX_CHUNK_SIZE ? 'large' : 'optimal';\n        \n        // Required dev fields\n        metadata.is_merged = chunk.is_merged || false;\n        metadata.is_split = chunk.is_split || false;\n        metadata.merged_chunk_count = chunk.merged_chunk_count || 1;\n        metadata.section_level = chunk.section_level;\n        metadata.section_title = chunk.section_title;\n        \n        // Split part information\n        if (chunk.is_split && chunk.split_part_number) {\n          metadata.split_part_number = chunk.split_part_number;\n        }\n        \n        // Additional dev info\n        if (chunk.is_split) {\n          metadata.chunk_index_in_section = chunk.chunk_index_in_section;\n        }\n        \n        if (chunk.original_chunks) {\n          metadata.original_chunks_info = chunk.original_chunks.map(c => ({\n            section_title: c.section_title,\n            size: c.size,\n            is_split: c.is_split\n          }));\n        }\n      }\n\n      return {\n        chunk: chunk.content,\n        chunk_metadata: metadata\n      };\n    });\n  }\n\n  // Extract heading mapping from original sections (before chunking)\n  extractHeadingMappingFromSections(sections) {\n    // Store sections for later chunk range mapping\n    this._original_sections = sections.map((section, index) => ({\n      ...section,\n      sectionIndex: index,\n      chunkStart: null, // Will be filled later\n      chunkEnd: null    // Will be filled later\n    }));\n    \n    // Return placeholder - we'll build the real hierarchy after chunk processing\n    return 'Hierarchy will be built after chunk processing...';\n  }\n\n  // Build final hierarchy with actual chunk ranges\n  buildFinalHierarchy(finalChunks) {\n    // Map chunks back to original sections\n    let currentChunkIndex = 0;\n    \n    this._original_sections.forEach((section, sectionIndex) => {\n      // Find chunks that belong to this section\n      const sectionChunks = finalChunks.filter(chunk => {\n        // Check if chunk belongs to this section by comparing section titles\n        return chunk.section_title === section.title && \n               chunk.original_section_title === section.original_title;\n      });\n      \n      if (sectionChunks.length > 0) {\n        // Find the actual chunk indices for this section\n        const chunkIndices = sectionChunks.map(chunk => \n          finalChunks.findIndex(c => c === chunk)\n        );\n        \n        section.chunkStart = Math.min(...chunkIndices);\n        section.chunkEnd = Math.max(...chunkIndices);\n      } else {\n        // No chunks found for this section (shouldn't happen)\n        section.chunkStart = currentChunkIndex;\n        section.chunkEnd = currentChunkIndex;\n      }\n      \n      currentChunkIndex++;\n    });\n    \n    // Now build the hierarchy display with correct chunk ranges\n    const lines = ['Doc Hierarchy with Chunk Indexes (From, To)', ''];\n    \n    // Simply list all sections in document order (lossless)\n    this._original_sections.forEach(section => {\n      const hierarchyStack = section.hierarchy_stack || [];\n      const depth = hierarchyStack.length - 1;\n      const indent = '  '.repeat(depth);\n      const prefix = depth > 0 ? ' ' : '';\n      \n      lines.push(`${indent}${prefix}${section.title} [${section.chunkStart},${section.chunkEnd}]`);\n    });\n    \n    return lines.join('\\n');\n  }\n\n  // Extract heading mapping for hierarchical index (OLD METHOD - keeping for now)\n  extractHeadingMapping(chunks) {\n    const sectionsArray = []; // Track all sections in order\n    const sectionsForChunkLookup = {}; // For parent_chunks lookup by chunk index\n    let currentSection = null;\n\n    for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {\n      const chunk = chunks[chunkIndex];\n      const hierarchyStack = chunk.hierarchy_stack || [];\n      \n      // Build full path from hierarchy stack\n      const fullPath = hierarchyStack.map(node => node.title).join(' > ');\n      \n      // Always create new sections for each heading occurrence\n      // Don't merge sections with the same name - treat each as separate\n\n      if (currentSection) {\n        sectionsArray.push(currentSection);\n      }\n\n      currentSection = {\n        path: fullPath,\n        level: chunk.section_level,\n        start: chunkIndex,\n        end: chunkIndex,\n        displayPath: fullPath // Keep original path for display\n      };\n      \n      // Add to chunk lookup\n      sectionsForChunkLookup[chunkIndex] = currentSection;\n    }\n\n    if (currentSection) {\n      sectionsArray.push(currentSection);\n    }\n\n    // Store sections mapping for use in chunk metadata (lookup by chunk index)\n    this._sections_mapping = sectionsForChunkLookup;\n\n    return this.buildTextTocFromArray(sectionsArray);\n  }\n\n  buildTextTocFromArray(sectionsArray) {\n    const lines = ['Doc Hierarchy with Chunk Indexes (From, To)', ''];\n    \n    // Build hierarchical structure with proper indentation\n    const rootSections = {};\n    \n    sectionsArray.forEach(section => {\n      const parts = section.displayPath.split(' > ');\n      const rootKey = parts[0];\n      \n      if (!rootSections[rootKey]) {\n        rootSections[rootKey] = {\n          range: [section.start, section.end],\n          children: []\n        };\n      } else {\n        rootSections[rootKey].range[0] = Math.min(rootSections[rootKey].range[0], section.start);\n        rootSections[rootKey].range[1] = Math.max(rootSections[rootKey].range[1], section.end);\n      }\n      \n      if (parts.length > 1) {\n        const childName = parts[parts.length - 1];\n        rootSections[rootKey].children.push({\n          name: childName,\n          range: [section.start, section.end]\n        });\n      }\n    });\n    \n    // Display with indentation\n    Object.keys(rootSections).forEach(rootName => {\n      const rootData = rootSections[rootName];\n      lines.push(`${rootName} [${rootData.range[0]},${rootData.range[1]}]`);\n      \n      rootData.children.forEach((child, j) => {\n        const isLastChild = j === rootData.children.length - 1;\n        const prefix = isLastChild ? ' ' : ' ';\n        lines.push(`${prefix}${child.name} [${child.range[0]},${child.range[1]}]`);\n      });\n    });\n    \n    return lines.join('\\n');\n  }\n\n  buildTextToc(sectionsDict) {\n    const lines = ['Doc Hierarchy with Chunk Indexes (From, To)', ''];\n    const rootSections = {};\n\n    for (const [path, section] of Object.entries(sectionsDict)) {\n      const parts = path.split(' > ');\n      const rootKey = parts[0];\n\n      if (!rootSections[rootKey]) {\n        rootSections[rootKey] = {\n          range: [section.start, section.end],\n          children: []\n        };\n      } else {\n        rootSections[rootKey].range[0] = Math.min(rootSections[rootKey].range[0], section.start);\n        rootSections[rootKey].range[1] = Math.max(rootSections[rootKey].range[1], section.end);\n      }\n\n      if (parts.length > 1) {\n        const childName = parts[parts.length - 1];\n        rootSections[rootKey].children.push({\n          name: childName,\n          range: [section.start, section.end]\n        });\n      }\n    }\n\n    const rootKeys = Object.keys(rootSections);\n    rootKeys.forEach((rootName, i) => {\n      const rootData = rootSections[rootName];\n      lines.push(`${rootName} [${rootData.range[0]},${rootData.range[1]}]`);\n\n      rootData.children.forEach((child, j) => {\n        const isLastChild = j === rootData.children.length - 1;\n        const prefix = isLastChild ? ' ' : ' ';\n        lines.push(`${prefix}${child.name} [${child.range[0]},${child.range[1]}]`);\n      });\n    });\n\n    return lines.join('\\n');\n  }\n\n  // Main processing method - implements the 4-step approach\n  chunkText(markdownContent) {\n    try {\n      console.log('Starting 4-step markdown chunking process...');\n\n      // STEP 1: Parse markdown by major headings (H1, H2, H3, H4, H5, H6)\n      const sections = this.parseMarkdownSections(markdownContent, [1, 2, 3, 4, 5, 6]);\n      console.log(`Step 1 - Parsed into ${sections.length} major sections`);\n\n      // STEP 2: Recursive markdown-aware splitting within sections\n      let allChunks = [];\n      for (const section of sections) {\n        const sectionChunks = this.splitSectionIntoChunks(section);\n        allChunks.push(...sectionChunks);\n      }\n      console.log(`Step 2 - Split into ${allChunks.length} chunks`);\n\n      // STEP 3: Merge small chunks intelligently\n      const mergedChunks = this.mergeSmallChunks(allChunks);\n      console.log(`Step 3 - After merging: ${mergedChunks.length} chunks`);\n\n            // STEP 4: Add document headline (only if contextual_embedding_enabled is false)\n      const contextualEmbeddingEnabled = $('Set Data').first().json.contextual_embedding_enabled;\n      const headlineToAdd = contextualEmbeddingEnabled ? null : DOCUMENT_HEADLINE;\n      const finalChunks = this.addDocumentHeadline(mergedChunks, headlineToAdd);\n      console.log(`Step 4 - Added document headline to ${finalChunks.length} chunks (contextual_embedding_enabled: ${contextualEmbeddingEnabled})`);\n\n\n      // Generate statistics\n      const sizeStats = finalChunks.map(chunk => chunk.size);\n      const tooSmall = sizeStats.filter(size => size < this.MIN_CHUNK_SIZE).length;\n      const tooLarge = sizeStats.filter(size => size > this.MAX_CHUNK_SIZE).length;\n      const optimal = sizeStats.filter(size => size >= this.MIN_CHUNK_SIZE && size <= this.MAX_CHUNK_SIZE).length;\n      console.log(`Size distribution - Too small: ${tooSmall}, Optimal: ${optimal}, Too large: ${tooLarge}`);\n\n      // Set total chunks\n      this._total_chunks = finalChunks.length;\n      \n      return this.createChunkMetadata(finalChunks);\n\n    } catch (error) {\n      return [{\n        error: true,\n        message: error.message,\n        stack: error.stack\n      }];\n    }\n  }\n\n  setDocumentSummary(summary) {\n    this._document_summary = summary;\n  }\n\n  getTotalChunks() {\n    return this._total_chunks;\n  }\n}\n\n// Main execution\nconst results = [];\n\nfor (const item of $input.all()) {\n  try {\n    // Get markdown content from the specified field\n    const markdownContent = item.json[MARKDOWN_FIELD];\n    \n    if (!markdownContent || typeof markdownContent !== 'string') {\n      throw new Error(`Field '${MARKDOWN_FIELD}' does not contain valid markdown text`);\n    }\n\n    // Get or generate document ID\n    const docId = DOCUMENT_ID_FIELD && item.json[DOCUMENT_ID_FIELD] \n      ? item.json[DOCUMENT_ID_FIELD] \n      : `doc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Create chunker instance\n    const chunker = new SmartMarkdownChunker(MIN_CHUNK_SIZE, MAX_CHUNK_SIZE, TARGET_CHUNK_SIZE, DEV_MODE);\n    \n    if (DOCUMENT_SUMMARY) {\n      chunker.setDocumentSummary(DOCUMENT_SUMMARY);\n    }\n\n    // Process the markdown\n    const processedChunks = chunker.chunkText(markdownContent);\n\n    // Build chunks array with metadata\n    const chunks = processedChunks.map(chunkData => ({\n      content: chunkData.chunk,\n      metadata: {\n        ...chunkData.chunk_metadata,\n        indexed_date: new Date().toISOString(),\n        doc_id: $('Set Data').first().json.doc_id,\n        doc_name: $('Set Data').first().json.doc_name,\n        ...((() => {\n          try { \n            const enrichmentData = $input.first().json.custom_metadata || {};\n            // Uppercase the first word of document_headline_description\n            if (enrichmentData.document_headline_description) {\n              const words = enrichmentData.document_headline_description.split(' ');\n              if (words.length > 0) {\n                words[0] = words[0].charAt(0).toUpperCase() + words[0].slice(1);\n                enrichmentData.document_headline_description = words.join(' ');\n              }\n            }\n            return enrichmentData;\n          }\n          catch { return {}; }\n        })())\n      }\n    }));\n\n    // Return just the chunks array\n    results.push({\n      json: {\n        chunks: chunks\n      }\n    });\n\n  } catch (error) {\n    // Add error item\n    results.push({\n      json: {\n        error: true,\n        message: error.message,\n        original_item: item.json\n      }\n    });\n  }\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5632,
        4736
      ],
      "id": "f1d8330b-97fe-42c0-8d7e-608376495e8b",
      "name": "Smart Chunker"
    },
    {
      "parameters": {
        "jsCode": "// Markdown Hierarchy Extractor for n8n Code Node\n// This tool extracts document hierarchy from markdown content independently of chunking\n\n// Input Mappings - adjust these to match your n8n workflow\nconst MARKDOWN_FIELD = 'content';  // Field name containing the original markdown text\nconst CHUNKS_FIELD = 'chunks';     // Field name containing processed chunks (optional)\n\n// Data source mappings - get actual data from n8n nodes\nconst MARKDOWN_SOURCE = () => $('Set up Text for Embedding').first().json.content;\nconst CHUNKS_SOURCE = () => $input.first().json.chunks;\n\nclass HierarchyNode {\n  constructor(title, level) {\n    this.title = title;\n    this.level = level;\n  }\n}\n\nclass MarkdownHierarchyExtractor {\n  constructor(maxHeadingLength = 200) {\n    this.MAX_HEADING_LENGTH = maxHeadingLength;\n  }\n\n  // Extract clean document hierarchy from markdown\n  extractHierarchy(markdownContent, headingLevels = [1, 2, 3, 4, 5, 6]) {\n    const lines = markdownContent.split('\\n');\n    const sections = [];\n    let currentSection = null;\n    let currentContent = [];\n    const hierarchyStack = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      const headingMatch = line.match(/^(#+)\\s*(.*)$/);\n      \n      if (headingMatch) {\n        const level = headingMatch[1].length;\n        \n        // Only process specified heading levels\n        if (headingLevels.includes(level)) {\n          // Save previous section if it exists\n          if (currentSection && currentContent.length > 0) {\n            currentSection.content = currentContent.join('\\n');\n            currentSection.contentLength = currentSection.content.length;\n            sections.push(currentSection);\n          }\n\n          const originalTitle = headingMatch[2].trim();\n          let displayTitle = originalTitle;\n\n          // Truncate extremely long headings for display\n          if (displayTitle.length > this.MAX_HEADING_LENGTH) {\n            displayTitle = displayTitle.substring(0, this.MAX_HEADING_LENGTH - 3) + '...';\n          }\n\n          // Update hierarchy stack\n          while (hierarchyStack.length >= level) {\n            hierarchyStack.pop();\n          }\n          hierarchyStack.push(new HierarchyNode(displayTitle, level));\n\n          currentSection = {\n            title: displayTitle,\n            originalTitle: originalTitle,\n            level,\n            hierarchyStack: JSON.parse(JSON.stringify(hierarchyStack)),\n            hierarchyPath: hierarchyStack.map(node => node.title).join(' > '),\n            content: '',\n            contentLength: 0,\n            sectionIndex: sections.length\n          };\n\n          currentContent = [line];\n        } else {\n          // Include sub-headings in content\n          currentContent.push(line);\n        }\n      } else {\n        currentContent.push(line);\n      }\n    }\n\n    // Don't forget the last section\n    if (currentSection && currentContent.length > 0) {\n      currentSection.content = currentContent.join('\\n');\n      currentSection.contentLength = currentSection.content.length;\n      sections.push(currentSection);\n    }\n\n    // If no major headings found, treat entire document as one section\n    if (sections.length === 0) {\n      sections.push({\n        title: 'Document',\n        originalTitle: 'Document',\n        level: 1,\n        hierarchyStack: [new HierarchyNode('Document', 1)],\n        hierarchyPath: 'Document',\n        content: markdownContent,\n        contentLength: markdownContent.length,\n        sectionIndex: 0\n      });\n    }\n\n    return sections;\n  }\n\n\n\n  // Helper method to get consecutive chunks from a starting point\n  getConsecutiveChunks(chunks, startIndex) {\n    if (!chunks || chunks.length === 0 || startIndex >= chunks.length) {\n      return [];\n    }\n\n    const result = [chunks[startIndex]];\n    const startChunkIndex = chunks[startIndex].metadata.chunk_index;\n    \n    // Look for consecutive chunks after the starting chunk\n    for (let i = startIndex + 1; i < chunks.length; i++) {\n      const currentChunkIndex = chunks[i].metadata.chunk_index;\n      const expectedNextIndex = result[result.length - 1].metadata.chunk_index + 1;\n      \n      if (currentChunkIndex === expectedNextIndex) {\n        result.push(chunks[i]);\n      } else {\n        // Break on first non-consecutive chunk\n        break;\n      }\n    }\n    \n    return result;\n  }\n\n  // Map sections to their corresponding chunk ranges\n  mapSectionsToChunks(sections, chunks) {\n    if (!chunks || !Array.isArray(chunks)) {\n      return sections.map(section => ({\n        ...section,\n        chunkRange: null,\n        chunkCount: 0\n      }));\n    }\n\n    // Sort chunks by index for sequential processing\n    const sortedChunks = [...chunks].sort((a, b) => a.metadata.chunk_index - b.metadata.chunk_index);\n    \n    // STEP 1: Single pass - map each section to its chunk index\n    const sectionToChunkMap = new Map(); // sectionIndex -> chunkIndex\n    let searchStartIndex = 0; // Only search forward, never backward\n    const usedChunks = new Set(); // Track which chunks have been fully processed\n    \n    console.log('=== SINGLE PASS MAPPING ===');\n    \n    sections.forEach(section => {\n      // Use the original title (not truncated) for searching in chunks\n      const searchTitle = section.originalTitle || section.title;\n      const headingPattern = `${'#'.repeat(section.level)} ${searchTitle}`;\n      \n      // Search for this section's heading starting from searchStartIndex\n      const foundChunks = [];\n      \n      for (let i = searchStartIndex; i < sortedChunks.length; i++) {\n        const chunk = sortedChunks[i];\n        const chunkContent = chunk.content || '';\n        \n        if (chunkContent.includes(headingPattern)) {\n          foundChunks.push(chunk.metadata.chunk_index);\n          \n          // If we found a match beyond the current search start, advance the search start\n          if (i > searchStartIndex) {\n            searchStartIndex = i;\n          }\n          \n          // Look for additional split parts by checking for the section heading in subsequent chunks\n          for (let j = i + 1; j < sortedChunks.length; j++) {\n            const nextChunk = sortedChunks[j];\n            const nextChunkContent = nextChunk.content || '';\n            \n            // Check if next chunk contains our section heading (indicating it's a split part)\n            if (nextChunkContent.includes(headingPattern) || \n                (nextChunk.metadata.split_part_number && \n                 nextChunk.metadata.total_chunks_in_section &&\n                 nextChunkContent.includes(section.title))) {\n              foundChunks.push(nextChunk.metadata.chunk_index);\n              \n              // If this chunk has split metadata, use it to determine how many more parts to look for\n              if (nextChunk.metadata.total_chunks_in_section) {\n                const totalParts = nextChunk.metadata.total_chunks_in_section;\n                if (foundChunks.length >= totalParts) {\n                  break;\n                }\n              }\n            } else {\n              // Stop if we don't find a related chunk\n              break;\n            }\n          }\n          \n          break;\n        }\n      }\n      \n      if (foundChunks.length > 0) {\n        // Store all chunks for this section\n        sectionToChunkMap.set(section.sectionIndex, foundChunks);\n        console.log(`Section ${section.sectionIndex}: \"${section.title}\"  Chunks [${foundChunks.join(',')}]`);\n      } else {\n        console.log(`Section ${section.sectionIndex}: \"${section.title}\"  NOT FOUND`);\n      }\n    });\n    \n    console.log('=== END SINGLE PASS MAPPING ===');\n\n    // STEP 2: Add mapped chunk index to each section (keep chunkIndices as-is for splits)\n    const sectionsWithChunks = sections.map(section => {\n      const mappedChunks = sectionToChunkMap.get(section.sectionIndex);\n      \n      if (!mappedChunks || mappedChunks.length === 0) {\n        return {\n          ...section,\n          mappedChunkIndex: null,\n          chunkRange: null,\n          chunkCount: 0,\n          chunkIndices: []\n        };\n      }\n\n      // For sections with multiple chunks (splits), use all of them\n      const allChunks = Array.isArray(mappedChunks) ? mappedChunks : [mappedChunks];\n      \n      return {\n        ...section,\n        mappedChunkIndex: allChunks[0], // First chunk index for backward compatibility\n        chunkRange: null, // Will be calculated in step 3\n        chunkCount: allChunks.length,\n        chunkIndices: allChunks.sort((a, b) => a - b)\n      };\n    });\n\n    // STEP 3: Calculate hierarchical chunk ranges based on document structure\n    const sectionsWithRanges = sectionsWithChunks.map((section, index) => {\n      if (!section.chunkIndices || section.chunkIndices.length === 0) {\n        return section;\n      }\n\n      // Find the range of chunks that belong to this section hierarchically\n      const startChunk = Math.min(...section.chunkIndices);\n      let endChunk = Math.max(...section.chunkIndices);\n\n      // Look ahead to find all chunks under this section until we hit a same-or-higher level\n      for (let i = index + 1; i < sectionsWithChunks.length; i++) {\n        const nextSection = sectionsWithChunks[i];\n        \n        // If we hit a section at the same level or higher, stop\n        if (nextSection.level <= section.level) {\n          break;\n        }\n        \n        // If the next section has chunks, extend our range to include them\n        if (nextSection.chunkIndices && nextSection.chunkIndices.length > 0) {\n          const nextSectionMaxChunk = Math.max(...nextSection.chunkIndices);\n          endChunk = Math.max(endChunk, nextSectionMaxChunk);\n        }\n      }\n\n      return {\n        ...section,\n        chunkRange: [startChunk, endChunk]\n      };\n    });\n\n    // STEP 4: Add parent ranges\n    return sectionsWithRanges.map((section, index) => {\n      let parentRange = null;\n\n      // Find the immediate parent (first section with lower level going backwards)\n      for (let i = index - 1; i >= 0; i--) {\n        const potentialParent = sectionsWithRanges[i];\n        \n        if (potentialParent.level < section.level) {\n          // Found the immediate parent\n          if (potentialParent.chunkRange) {\n            parentRange = potentialParent.chunkRange;\n          }\n          break;\n        }\n      }\n\n      return {\n        ...section,\n        parentRange: parentRange\n      };\n    });\n  }\n\n  // Build hierarchical index with section ranges\n  buildHierarchicalIndex(sectionsWithChunks) {\n    const lines = ['Document Hierarchy with Chunk Index Ranges', ''];\n    \n    sectionsWithChunks.forEach(section => {\n      const hashes = '#'.repeat(section.level);\n      let chunkInfo = '';\n      \n      if (section.chunkRange) {\n        const [start, end] = section.chunkRange;\n        chunkInfo = start === end ? ` [${start}]` : ` [${start}-${end}]`;\n      } else {\n        chunkInfo = ' [no chunks]';\n      }\n      \n      lines.push(`${hashes} ${section.title}${chunkInfo}`);\n    });\n    \n    return lines.join('\\n');\n  }\n\n}\n\n// Main execution for n8n\nconst results = [];\n\ntry {\n  // Get markdown content from specified node\n  const markdownContent = MARKDOWN_SOURCE();\n  \n  if (!markdownContent || typeof markdownContent !== 'string') {\n    throw new Error('No valid markdown content found from source node');\n  }\n\n  // Get chunks if available (optional)\n  const chunks = (() => {\n    try { return CHUNKS_SOURCE(); }\n    catch { return null; }\n  })();\n\n  // Create hierarchy extractor\n  const extractor = new MarkdownHierarchyExtractor();\n  \n  // Extract sections from original markdown\n  const sections = extractor.extractHierarchy(markdownContent);\n  \n  // Map sections to chunks (if chunks provided)\n  const sectionsWithChunks = extractor.mapSectionsToChunks(sections, chunks);\n  \n  // Build hierarchical index\n  const hierarchicalIndex = extractor.buildHierarchicalIndex(sectionsWithChunks);\n\n  // Get enrichment data if available\n  const enrichmentData = (() => {\n    try { return $('Set up Text for Embedding').first().json.custom_metadata || {}; }\n    catch { return {}; }\n  })();\n\n  // Build document metadata\n  const documentMetadata = {\n    totalSections: sections.length,\n    hierarchicalIndex: hierarchicalIndex,\n    processingTimestamp: new Date().toISOString(),\n    doc_id: (() => {\n      try { return $('Set Data').first().json.doc_id; }\n      catch { return null; }\n    })(),\n    doc_name: (() => {\n      try { return $('Set Data').first().json.doc_name; }\n      catch { return null; }\n    })(),\n    ...enrichmentData\n  };\n\n  // Return comprehensive hierarchy information\n  results.push({\n    json: {\n      sections: sectionsWithChunks.map(section => ({\n        sectionIndex: section.sectionIndex,\n        title: section.title,\n        // originalTitle: section.originalTitle,\n        level: section.level,\n        hierarchyPath: section.hierarchyPath,\n        // contentLength: section.contentLength,\n        // mappedChunkIndex: section.mappedChunkIndex,\n        chunkIndices: section.chunkIndices,\n        sectionRange: section.chunkRange,\n        parentRange: section.parentRange,\n        // chunkCount: section.chunkCount,\n        // Don't include full content to keep output manageable\n        // contentPreview: section.content ? section.content.substring(0, 200) + (section.content.length > 200 ? '...' : '') : ''\n      })),\n      document: documentMetadata\n    }\n  });\n\n} catch (error) {\n  results.push({\n    json: {\n      error: true,\n      message: error.message,\n      stack: error.stack\n    }\n  });\n}\n\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5840,
        4736
      ],
      "id": "cdcbdf83-9b80-4331-b0fb-87e0416122e5",
      "name": "Document Hierarchy Extractor"
    },
    {
      "parameters": {
        "jsCode": "// Chunk-Section Merger for n8n Code Node\n// This tool merges sections and chunks data, adding section ranges to chunk metadata\n\n// Input Mappings - adjust these to match your n8n workflow\nconst SECTIONS_SOURCE = () => $('Document Hierarchy Extractor').first().json.sections;\nconst CHUNKS_SOURCE = () => $('Smart Chunker').first().json.chunks;\n\nclass ChunkSectionMerger {\n  constructor() {\n    // No configuration needed\n  }\n\n  // Merge sections data into chunks metadata\n  mergeData(sections, chunks) {\n    if (!sections || !Array.isArray(sections)) {\n      throw new Error('Invalid sections data provided');\n    }\n    \n    if (!chunks || !Array.isArray(chunks)) {\n      throw new Error('Invalid chunks data provided');\n    }\n\n    // Create a map of chunk_index -> sections that reference it\n    const chunkToSectionsMap = new Map();\n\n    // Process each section to build the mapping\n    sections.forEach(section => {\n      if (section.chunkIndices && Array.isArray(section.chunkIndices)) {\n        section.chunkIndices.forEach(chunkIndex => {\n          if (!chunkToSectionsMap.has(chunkIndex)) {\n            chunkToSectionsMap.set(chunkIndex, []);\n          }\n          chunkToSectionsMap.get(chunkIndex).push(section);\n        });\n      }\n    });\n\n    // Process each chunk and add section range metadata\n    return chunks.map(chunk => {\n      const chunkIndex = chunk.metadata.chunk_index;\n      const sectionsForChunk = chunkToSectionsMap.get(chunkIndex) || [];\n\n      let sectionRange = null;\n      let parentRange = null;\n\n      if (sectionsForChunk.length > 0) {\n        // Find absolute lowest and highest section ranges\n        const allSectionRanges = sectionsForChunk\n          .filter(section => section.sectionRange && Array.isArray(section.sectionRange))\n          .map(section => section.sectionRange);\n\n        if (allSectionRanges.length > 0) {\n          const allStarts = allSectionRanges.map(range => range[0]);\n          const allEnds = allSectionRanges.map(range => range[1]);\n          sectionRange = [Math.min(...allStarts), Math.max(...allEnds)];\n        }\n\n        // Find absolute lowest and highest parent ranges\n        const allParentRanges = sectionsForChunk\n          .filter(section => section.parentRange && Array.isArray(section.parentRange))\n          .map(section => section.parentRange);\n\n        if (allParentRanges.length > 0) {\n          const allParentStarts = allParentRanges.map(range => range[0]);\n          const allParentEnds = allParentRanges.map(range => range[1]);\n          parentRange = [Math.min(...allParentStarts), Math.max(...allParentEnds)];\n        }\n      }\n\n      // Return chunk with enhanced metadata\n      return {\n        ...chunk,\n        metadata: {\n          ...chunk.metadata,\n          childRange: sectionRange,\n          parentRange: parentRange\n        }\n      };\n    });\n  }\n}\n\n// Main execution for n8n\nconst results = [];\n\ntry {\n  // Get sections and chunks data\n  const sections = SECTIONS_SOURCE();\n  const chunks = CHUNKS_SOURCE();\n\n  if (!sections) {\n    throw new Error('No sections data found from Hierarchy Extractor node');\n  }\n\n  if (!chunks) {\n    throw new Error('No chunks data found from Smart Markdown Chunker node');\n  }\n\n  // Create merger and process data\n  const merger = new ChunkSectionMerger();\n  const enhancedChunks = merger.mergeData(sections, chunks);\n\n  // Return enhanced chunks\n  results.push({\n    json: {\n      chunks: enhancedChunks,\n      totalChunks: enhancedChunks.length,\n      processingTimestamp: new Date().toISOString()\n    }\n  });\n\n} catch (error) {\n  results.push({\n    json: {\n      error: true,\n      message: error.message,\n      stack: error.stack\n    }\n  });\n}\n\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6032,
        4736
      ],
      "id": "3322460d-5306-4fcc-86f3-283c449b7774",
      "name": "Merger"
    },
    {
      "parameters": {
        "fieldToSplitOut": "chunks",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        6096,
        5024
      ],
      "id": "33913e84-2039-4e0b-ac07-14812be7e1dd",
      "name": "Split Out1"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "record_manager_v2",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Create Row in Record Manager').isExecuted ? $('Create Row in Record Manager').first().json.id : $('Search Record Manager').first().json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "hierarchical_index",
              "fieldValue": "={{ $('Document Hierarchy Extractor').item.json.document.hierarchicalIndex }}"
            },
            {
              "fieldId": "document_headline",
              "fieldValue": "={{ $('Merger').first().json.chunks[0].metadata.document_headline_description }}"
            },
            {
              "fieldId": "document_summary",
              "fieldValue": "={{ $('Document Hierarchy Extractor').item.json.document.document_summary }}"
            },
            {
              "fieldId": "status",
              "fieldValue": "complete"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        7664,
        5424
      ],
      "id": "127431f9-c959-455c-bcd5-8015c1793812",
      "name": "Update our Record Manager1",
      "retryOnFail": true
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        10512,
        5488
      ],
      "id": "13799ea9-d79a-4196-8533-3a8ad635167d",
      "name": "Next1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "2d3a9569-f099-4136-84d0-6987e691d58b",
              "leftValue": "={{ $('Set Data').first().json.doc_type }}",
              "rightValue": "file",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        256,
        2400
      ],
      "id": "beb2d1bf-05c5-4f02-8f65-e4c50332effe",
      "name": "If a file"
    },
    {
      "parameters": {
        "content": "## Loop End\nArchive and move to next item",
        "height": 304,
        "width": 256,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        176,
        2304
      ],
      "id": "3338c731-007c-41bd-a7bf-6216b9b6611a",
      "name": "Sticky Note32"
    },
    {
      "parameters": {
        "jsCode": "// Get the text from the previous node\nconst inputText = $('Set Text (Merged)').first().json.text;\n\n// Define the page marker pattern\nconst pageMarkerPattern = /<<<PAGE_START:\\d+>>>\\s*/g;\n\n// Remove all page markers\nconst cleanedText = inputText.replace(pageMarkerPattern, '');\n\n// Return the cleaned text\nreturn [{\n  json: {\n    text: cleanedText\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4112,
        4048
      ],
      "id": "ca9d7dff-2366-47a7-b966-61c98e6ec441",
      "name": "Remove Page Number Placeholders"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Here is the chunk we want to situate within the whole document \n<chunk> \n{{ $json.content }}\n</chunk> \nPlease give a short succinct context to situate this chunk within the overall document for the purposes of improving search retrieval of the chunk. Answer only with the succinct context and nothing else. ",
        "messages": {
          "messageValues": [
            {
              "message": "=<document> \n{{ $('Set up Text for Embedding').item.json.content }} \n</document> "
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        7200,
        4656
      ],
      "id": "343afd1f-2485-4b58-be59-c90ee001d134",
      "name": "Basic LLM Chain",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-5-mini",
          "mode": "list",
          "cachedResultName": "gpt-5-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        7200,
        4832
      ],
      "id": "49a58eb0-e585-4372-8b58-3a5737ef68bb",
      "name": "OpenAI Chat Model"
    },
    {
      "parameters": {
        "amount": 1
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        4624,
        4080
      ],
      "id": "6b6e8f89-5f7b-4acc-a241-d902aa7f9cf9",
      "name": "Wait3",
      "webhookId": "359ab095-cb8b-4b07-bc9f-73c1fea452c0"
    },
    {
      "parameters": {
        "content": "## Set Folder",
        "height": 280,
        "width": 232
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1328,
        1968
      ],
      "id": "a3120347-9fa4-4e38-ac78-e6740c43b210",
      "name": "Sticky Note38"
    },
    {
      "parameters": {
        "content": "## Set Folder",
        "height": 280,
        "width": 232
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        480,
        2304
      ],
      "id": "c56a9e0a-d969-4c36-948e-f1a3907dc349",
      "name": "Sticky Note39"
    },
    {
      "parameters": {
        "content": "## Set Folder",
        "height": 232,
        "width": 232
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        464,
        1552
      ],
      "id": "c89dabbe-3a5e-43e2-a1af-1d4fabe900ca",
      "name": "Sticky Note40"
    },
    {
      "parameters": {
        "content": "## Set Folder",
        "height": 232,
        "width": 232
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        464,
        1312
      ],
      "id": "71e9ea83-88d6-483d-b5fa-6543dcbd6615",
      "name": "Sticky Note41"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "3d022e79-b19a-4d4b-8e64-eeea2d7500a5",
              "leftValue": "={{ $json.status }}",
              "rightValue": "complete",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            },
            {
              "id": "2a5fdcd6-162b-4f6b-ae1a-4b808619ef18",
              "leftValue": "={{ $json.status }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "empty",
                "singleValue": true
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2160,
        4736
      ],
      "id": "14f60c0b-6732-4c56-a4ab-f0b506cb8875",
      "name": "If Record is Complete"
    },
    {
      "parameters": {
        "content": "## Rate Limiting\nIf you run in to LLM Rate Limiting issues with LightRAG processing you can slow down file ingestion here",
        "height": 304,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        4576,
        3920
      ],
      "id": "addfe4ff-37a3-4119-8f2c-a828bcab61b7",
      "name": "Sticky Note43"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "record_manager_v2",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Create Row in Record Manager').isExecuted ? $('Create Row in Record Manager').first().json.id : $('Search Record Manager').first().json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "status",
              "fieldValue": "error"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        8960,
        4096
      ],
      "id": "bf0c6494-66c5-4ed6-b116-b04b5d0fdebb",
      "name": "Update our Record Manager2",
      "retryOnFail": true
    },
    {
      "parameters": {
        "errorMessage": "={{ $('Error Message').item.json.error }}"
      },
      "type": "n8n-nodes-base.stopAndError",
      "typeVersion": 1,
      "position": [
        9136,
        4096
      ],
      "id": "c731b6dd-b767-4e34-987c-23e01c963a55",
      "name": "Stop and Error"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "1ddf5b25-bae7-4e91-b6d3-3b7a5e2486fa",
              "name": "error",
              "value": "={{ $json.error }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        8784,
        4096
      ],
      "id": "46b041ee-918f-4bd9-ac8d-5f3656d9d442",
      "name": "Error Message"
    },
    {
      "parameters": {
        "content": "## Rate Limiting - Fall Backs\nYou can copy the above LLM Chain and output parser and hook up a different API account or different API service. \n\nThe error track from the above node will feed this new node and success will merge into the \"Setup Text for Embedding\" node\n\nThe same can be done for the \"Basic LLM Chain within the Contextual Embedding\" and the \"Create OpenAI Embeddings\" calls",
        "height": 272,
        "width": 384,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        4832,
        4992
      ],
      "id": "b0a12ce3-2427-4148-8d6b-87db30703797",
      "name": "Sticky Note35"
    }
  ],
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "shared": [
    {
      "updatedAt": "2025-11-02T22:28:00.934Z",
      "createdAt": "2025-11-02T22:28:00.934Z",
      "role": "workflow:owner",
      "workflowId": "T5shLbYURAidLgsc",
      "projectId": "zIvgruNDMJwjqAqX"
    }
  ],
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-12-02T18:43:32.000Z",
  "versionId": "f33646f7-d0ce-4c8f-a819-499b77c9efd4"
}